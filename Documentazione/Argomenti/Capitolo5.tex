\chapter{Schema fisico}
    \section{Creazione schema}
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE SCHEMA azienda AUTHORIZATION postgres;
                \end{description}
            \end{flushleft}
        \normalfont

    \section{Creazione domini}
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE DOMAIN azienda.STRING AS VARCHAR(30);

                    \vspace{0.5cm}
                    
                    \item CREATE DOMAIN azienda.EURO AS NUMERIC(20, 2)\\
                            CONSTRAINT POSITIVE\_EURO\\
	                       CHECK (VALUE \(>=\) 0);

                    \vspace{0.5cm}
                        
                    \item CREATE DOMAIN azienda.MATRICOLA AS VARCHAR(8);\\
                            CONSTRAINT DOM\_MATRICOLA\_CHECK\_LENGTH\\
                                CHECK (LENGTH(VALUE) = 8);

                    \vspace{0.5cm}
                                
                    \item CREATE DOMAIN azienda.CUP AS VARCHAR(15);\\
                            CONSTRAINT DOM\_CUP\_CHECK\_LENGTH\\
                                CHECK (LENGTH(VALUE) = 15);\\
                                CONSTRAINT DOM\_CUP\_CHECK\_ALPHANUMERIC\\
                                CHECK (VALUE \texttildelow '[[:alnum:]]{15}');

                    \vspace{0.5cm}
                                
                    \item CREATE DOMAIN azienda.CODFISCALE AS VARCHAR(16)\\
                            CONSTRAINT DOM\_CODFISCALE\_CHECK\_LENGTH\\
                                CHECK (LENGTH(VALUE) = 16);\\
                            CONSTRAINT DOM\_CODFISCALE\_ALPHANUMERIC\\
                                CHECK (VALUE \texttildelow '[[:alnum:]]{16}');

                    \vspace{0.5cm}
                                
                    \item CREATE DOMAIN azienda.TIPO\_DIPENDENTE AS VARCHAR(6)\\
                            CONSTRAINT DOM\_TIPO\_DIPENDENTE\_CHECK\_JMS\\
                            CHECK (UPPER(VALUE) IN ('JUNIOR', 'MIDDLE', 'SENIOR'));

                    \vspace{0.5cm}
                            
                    \item CREATE DOMAIN azienda.TIPO\_SCATTO AS VARCHAR(20)\\
                            CONSTRAINT DOM\_TIPO\_SCATTO\_CHECK\_MSD\\
                                CHECK (UPPER(VALUE) IN ('MIDDLE', 'SENIOR', 'PROMOSSO A DIRIGENTE', 'RIMOSSO DA DIRIGENTE'));
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

    \section{Creazione tabelle}
        \subsection{DIP\_INDETERMINATO}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.DIP\_INDETERMINATO(                
                        \begin{description}
                            \item Matricola azienda.MATRICOLA NOT NULL,
                            \item Tipo azienda.TIPO\_DIPENDENTE NOT NULL DEFAULT 'Junior',
                            \item Nome azienda.STRING NOT NULL,
                            \item Cognome azienda.STRING NOT NULL,
                            \item codFiscale azienda.CODFISCALE NOT NULL,
                            \item Indirizzo VARCHAR(100),
                            \item dataNascita DATE NOT NULL,
                            \item dataAssunzione DATE NOT NULL DEFAULT FALSE,
                            \item dataFine DATE,
                            \item Dirigente BOOLEAN NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_dip\_indeterminato PRIMARY KEY (Matricola),
                            \item CONSTRAINT check\_ordine\_date\_di CHECK (dataNascita < dataAssunzione AND dataAssunzione <= dataFine)
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{SCATTO\_CARRIERA}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.SCATTO\_CARRIERA(                
                        \begin{description}
                            \item Matricola azienda.MATRICOLA NOT NULL,
                            \item Tipo azienda.TIPO\_SCATTO NOT NULL,
                            \item Data DATE NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_scatto\_carriera PRIMARY KEY (Matricola, Tipo, Data),
                            \item CONSTRAINT fk\_matricola\_scatto\_carriera FOREIGN KEY (Matricola)\\
                            REFERENCES azienda.dip\_indeterminato(Matricola)\\
                            ON DELETE CASCADE	ON UPDATE CASCADE
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

\newpage

        \subsection{LABORATORIO}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.LABORATORIO(                
                        \begin{description}
                            \item Nome azienda.STRING NOT NULL,
                            \item Topic azienda.STRING NOT NULL,
                            \item nAfferenti INTEGER NOT NULL DEFAULT 1,
                            \item Responsabile\_Scientifico azienda.MATRICOLA NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_laboratorio PRIMARY KEY (Nome),
                            \item CONSTRAINT fk\_responsabile\_scientifico\_laboratorio FOREIGN KEY (Responsabile\_Scientifico)\\
                            REFERENCES azienda.dip\_indeterminato(Matricola)\\
                            ON DELETE NO ACTION		ON UPDATE CASCADE,
                            \item CONSTRAINT check\_positive\_nAfferenti CHECK (nAfferenti > 0)
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{AFFERIRE}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.AFFERIRE(                
                        \begin{description}
                            \item Matricola azienda.MATRICOLA NOT NULL,
                            \item nomeLab azienda.STRING NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_afferire PRIMARY KEY (Matricola, nomeLab),
                            \item CONSTRAINT fk\_matricola\_afferire FOREIGN KEY (Matricola)\\
                            REFERENCES azienda.dip\_indeterminato(Matricola)\\
                            ON DELETE CASCADE	ON UPDATE CASCADE,
                            \item CONSTRAINT fk\_nome\_afferire FOREIGN KEY (nomeLab)\\
                            REFERENCES azienda.laboratorio(Nome)\\
                            ON DELETE CASCADE	ON UPDATE CASCADE
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

\newpage

        \subsection{PROGETTO}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.PROGETTO(                
                        \begin{description}
                            \item CUP azienda.CUP NOT NULL,
                            \item Nome azienda.STRING,
                            \item dataInizio DATE NOT NULL,
                            \item dataFine DATE,
                            \item Budget azienda.EURO NOT NULL,
                            \item costoAttrezzature azienda.EURO NOT NULL DEFAULT 0,
                            \item costoContrattiProgetto azienda.EURO NOT NULL DEFAULT 0,
                            \item Referente\_Scientifico azienda.MATRICOLA NOT NULL,
                            \item Responsabile azienda.MATRICOLA NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_progetto PRIMARY KEY (CUP),
                            \item CONSTRAINT fk\_referente\_scientifico\_progetto FOREIGN KEY (Referente\_Scientifico)\\
                            REFERENCES azienda.dip\_indeterminato(Matricola)\\
                            ON DELETE NO ACTION		ON UPDATE CASCADE,
                            \item CONTRAINT fk\_responsabile\_scientifico\_progetto FOREIGN KEY (Responsabile)\\
                            REFERENCES azienda.dip\_indeterminato(Matricola)\\
                            ON DELETE NO ACTION		ON UPDATE CASCADE,
                            \item CONSTRAINT nome\_progetto\_unico UNIQUE(Nome),
                            \item CONSTRAINT check\_positive\_budget CHECK (Budget > 0),
                            \item CONSTRAINT check\_date\_fine\_inizio CHECK (dataInizio <= dataFine)
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{LAVORARE}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.LAVORARE(                
                        \begin{description}
                            \item CUP azienda.CUP NOT NULL,
                            \item nomeLab azienda.STRING NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_lavorare PRIMARY KEY (CUP, nomeLab),
                            \item CONSTRAINT fk\_cup\_lavorare FOREIGN KEY (CUP)\\
                            REFERENCES azienda.progetto(CUP)\\
                            ON DELETE CASCADE	    ON UPDATE CASCADE,
                            \item CONSTRAINT fk\_nome\_lavorare FOREIGN KEY (nomeLab)\\
                            REFERENCES azienda.laboratorio(Nome)\\
                            ON DELETE CASCADE	ON UPDATE CASCADE
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{ATTREZZATURA}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.ATTREZZATURA(                
                        \begin{description}
                            \item idAttrezzatura SERIAL NOT NULL,
                            \item Descrizione VARCHAR(256) NOT NULL,
                            \item Costo azienda.EURO NOT NULL,
                            \item nomeLab azienda.STRING,
                            \item CUP azienda.CUP NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_attrezzatura PRIMARY KEY (idAttrezzatura),
                            \item CONSTRAINT fk\_nome\_attrezzatura FOREIGN KEY (nomeLab)\\
                            REFERENCES azienda.laboratorio(Nome)\\
                            ON DELETE SET NULL		ON UPDATE CASCADE,
                            \item CONSTRAINT fk\_cup\_attrezzatura FOREIGN KEY (CUP)\\
                            REFERENCES azienda.progetto(CUP)\\
                            ON DELETE CASCADE	    ON UPDATE CASCADE
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont


        \subsection{DIP\_PROGETTO}
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE TABLE azienda.DIP\_PROGETTO(                
                        \begin{description}
                            \item Matricola azienda.Matricola NOT NULL,
                            \item Nome azienda.STRING NOT NULL,
                            \item Cognome azienda.STRING NOT NULL,
                            \item codFiscale azienda.CODFISCALE NOT NULL,
                            \item Indirizzo VARCHAR(100),
                            \item dataNascita DATE NOT NULL,
                            \item dataAssunzione DATE NOT NULL,
                            \item Costo azienda.EURO NOT NULL,
                            \item Scadenza DATE NOT NULL,
                            \item CUP azienda.CUP NOT NULL,
                            
                            \vspace{0.5cm}

                            \item CONSTRAINT pk\_dip\_progetto PRIMARY KEY (Matricola),
                            \item CONSTRAINT fk\_cup\_dip\_progetto FOREIGN KEY (CUP)\\
                            REFERENCES azienda.progetto(CUP)\\
                            ON DELETE CASCADE	ON UPDATE CASCADE,
                            \item CONSTRAINT check\_ordine\_date\_dp CHECK (dataNascita < dataAssunzione AND dataAssunzione <= Scadenza)
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

    \newpage	    
    
	\section{Dizionario dei vincoli}
	    Di seguito verranno riportati i vincoli basati sullo schema.\\
	    Successivamente, nella sezione relativa ai trigger, verranno analizzati i vincoli di integrità semantica.

        \begin{center}
            \begin{tabular}{|C{2.5cm}|C{3.2cm}|L{9cm}|}
                \hline
                    \textbf{Concetto} 
                    & \textbf{Vincolo} 
                    & \textbf{Descrizione}\\
                \hline
                    \multirow{2}{2.5cm}[-0cm]{\centering azienda.STRING (Dominio)}
                    & Tipo: VARCHAR(30)
                    & \textbf{Vincolo di dominio} per gli attributi "Nome" e "Cognome" nella tabella DIP\_INDETERMINATO, per gli attributi "Nome" e "Topic" nella tabella LABORATORIO, per l' attributo "nomeLab" nella tabella AFFERIRE, per l' attributo "Nome" nella tabella PROGETTO, per l' attributo "nomeLab" nella tabella LAVORARE, per gli attributi "Nome" e "Cognome" nella tabella DIP\_PROGETTO.\\
                 
                \hline
                    \multirow{2}{2.5cm}[-0cm]{\centering azienda.EURO (Dominio)}
                    & Tipo: NUMERIC(20, 2)
                    & \textbf{Vincolo di dominio} applicato agli attributi "Budget", "costoAttrezzature" e "costoContrattiProgetto" per la tabella PROGETTO, per l'attributo "Costo" per la tabella ATTREZZATURA e per l'attributo "Costo" per la tabella DIP\_PROGETTO.\\
                    
                \cline{2-3}
                    & POSITIVE\_EURO
                    & \textbf{Vincolo di dominio} che controlla che il costo di un acquisto o il budget di un progetto sia non negativo.\\
                
                \hline
                    \multirow{3}{2.5cm}[-1cm]{\centering azienda.CUP (Dominio)}
                    & Tipo: VARCHAR(15)
                    & \textbf{Vincolo di dominio} applicato all'attributo "CUP" nelle tabelle PROGETTO, LAVORARE, ATTREZZATURA e DIP\_PROGETTO.\\
                    
                \cline{2-3}
                    & DOM\_CUP\_CHECK\_ LENGTH
                    & \textbf{Vincolo di dominio} che controlla che il CUP di un progetto rispetti la lunghezza di 15 caratteri.\\
                    
                \cline{2-3}
                    & DOM\_CUP\_CHECK\_ ALPHANUMERIC
                    & \textbf{Vincolo di dominio} che controlla che il CUP di un progetto sia alfanumerico.\\
            
                \hline
                    \multirow{3}{2.5cm}[-1cm]{\centering azienda.COD- FISCALE (Dominio)}
                    & Tipo: VARCHAR(16)
                    & \textbf{Vincolo di dominio} applicato all'attributo "codFiscale" nelle tabelle DIP\_INDETERMINATO e DIP\_PROGETTO.\\
                    
                \cline{2-3}
                    & DOM\_ CODFISCALE\_ CHECK\_LENGTH
                    & \textbf{Vincolo di dominio} che controlla che il codice fiscale di un dipendente rispetti la lunghezza di 16 caratteri.\\
            
                \cline{2-3}
                    & DOM\_ CODFISCALE\_ CHECK\_ ALPHANUMERIC
                    & \textbf{Vincolo di dominio} che controlla che il codice fiscale di un dipendente sia alfanumerico.\\
                \hline
                    \multirow{2}{2.5cm}[-1cm]{\centering azienda.TIPO \_DIPENDENTE (Dominio)}
                    & Tipo: VARCHAR(6)
                    & \textbf{Vincolo di dominio} applicato all'attributo "Tipo" nella tabella DIP\_INDETERMINATO.\\
                    
                \cline{2-3}
                    & DOM\_TIPO\_ DIPENDENTE\_  CHECK\_JMS
                    & \textbf{Vincolo di dominio} che controlla che il tipo di un dipendente sia:
                    
                    \begin{itemize}
                        \item \textit{Junior},
                        \item \textit{Middle},
                        \item \textit{Senior}.
                    \end{itemize}\\
                \hline
            \end{tabular}
        \end{center}
        
        \begin{center}
            \begin{tabular}{|C{2.5cm}|C{3.2cm}|L{9cm}|}
                \hline
                    \textbf{Concetto} 
                    & \textbf{Vincolo} 
                    & \textbf{Descrizione}\\
                \hline
                    \multirow{2}{2.5cm}[-1cm]{\centering azienda.TIPO \_SCATTO (Dominio)}
                    & Tipo: VARCHAR(20)
                    & \textbf{Vincolo di dominio} applicato all'attributo "Tipo" nella tabella SCATTO\_CARRIERA.\\
                    
                \cline{2-3}
                    & DOM\_ TIPO\_SCATTO \_CHECK\_MSD
                    & \textbf{Vincolo di dominio} che controlla che il tipo di scatto di un dipendente sia:
                    
                    \begin{itemize}
                        \item \textit{Middle},
                        \item \textit{Senior},
                        \item \textit{Promosso a dirigente},
                        \item \textit{Rimosso da dirigente}.
                    \end{itemize}\\
                \hline
                    \multirow{2}{2.5cm}[-0.8cm]{\centering DIP\_INDET- ERMINATO (Relazione)}
                    & pk\_dip\_ indeterminato
                    & \textbf{Vincolo di chiave primaria} per l'attributo "Matricola"\\
                \cline{2-3}
    
                    & check\_ordine\_date\_di
                    & \textbf{Vincolo di dominio}, riguardante gli attributi "dataNascita", "dataAssunzione" e "dataFine", dove si controlla che non sia possibile assumere un dipendente non ancora nato oppure licenziare un dipendente non ancora assunto\\
                    
                \hline
                    \multirow{2}{2.5cm}[-1.2cm]{\centering SCATTO\_ CARRIERA (Relazione)}
                    & pk\_scatto\_carriera
                    & \textbf{Vincolo di chiave primaria} che comprende gli attributi "Matricola", "Tipo" e "Data"\\
                \cline{2-3}
                
                    & fk\_matricola\_ scatto\_carriera
                    & \textbf{Vincolo di chiave esterna} dell'attributo "Matricola", il quale fa riferimento all'attributo \textit{chiave primaria} "Matricola" della relazione DIP\_INDETERMINATO. Infatti, ogni scatto di carriera corrisponderà ad uno specifico dipendente a tempo indeterminato. Se si elimina o si aggiorna la matricola di un dipendente a tempo indeterminato, verranno cancellati o aggiornati anche tutti gli scatti ad esso relativi.\\
                \hline
                    \multirow{3}{2.5cm}[-2cm]{\centering LABORATO- RIO (Relazione)}
                    & pk\_laboratorio
                    & \textbf{Vincolo di chiave primaria} per l'attributo "Nome"\\
                \cline{2-3}
                
                    & fk\_responsabile\_ scientifico\_ laboratorio 
                    & \textbf{Vincolo di chiave esterna} dell'attributo "Responsabile\_scientifico", il quale fa riferimento all'attributo \textit{chiave primaria} "Matricola" della relazione DIP\_INDETERMINATO. Infatti, ogni responsabile scientifico di un laboratorio corrisponde ad un dipendente a tempo indeterminato, ed ogni laboratorio non ne può essere sprovvisto. Se si intende eliminare un dipendente che è responsabile scientifico di un laboratorio, l'azione verrà impedita. Se si aggiorna la sua matricola, verrà aggiornata anche ogni sua occorrenza tra i responsabili scientifici.\\
                \cline{2-3}
                    & check\_positive\_ nAfferenti
                    & \textbf{Vincolo di dominio}, riguardante l'attributo "nAfferenti", dove si controlla che quest'ultimo non possa essere negativo. In particolare, deve essere strettamente maggiore di 0, poiché ogni laboratorio ha come minimo un'afferenza: quella del responsabile scientifico.\\
                \hline
            \end{tabular}
        \end{center}


        \begin{center}
            \begin{tabular}{|C{2.5cm}|C{3.2cm}|L{9cm}|}
                \hline
                    \textbf{Concetto} 
                    & \textbf{Vincolo} 
                    & \textbf{Descrizione}\\
                \hline
                    \multirow{3}{2.5cm}[-0.8cm]{\centering AFFERIRE (Relazione)}
                    & pk\_afferire 
                    & \textbf{Vincolo di chiave primaria} per gli attributi "Matricola" e "nomeLab".\\
                
                \cline{2-3}
                    & fk\_matricola\_afferire
                    & \textbf{Vincolo di chiave esterna} dell'attributo "Matricola", il quale fa riferimento all'attributo \textit{chiave primaria} "Matricola"
                    della relazione "DIP\_INDETERMINATO". Se si intende eliminare un dipendente a tempo indeterminato, verranno eliminate tutte le sue afferenze. Se, invece, si intende aggiornarne la matricola, verranno modificate tutte le sue occorrenze con la nuova.\\
                    
                \cline{2-3}
                    & fk\_nome\_afferire
                    & \textbf{Vincolo di chiave esterna} dell'attributo "nomeLab", il quale fa riferimento all'attributo \textit{chiave primaria}
                    "Nome" della relazione "LABORATORIO". Se si intende eliminare un laboratorio, verranno eliminate tutte le afferenze a quel laboratorio. Se, invece, si intende aggiornarne il nome del laboratorio, verranno modificate tutte le sue occorrenze.\\

                \hline
                    \multirow{6}{2.5cm}[-1.2cm]{\centering PROGETTO (Relazione)}
                    & pk\_progetto
                    & \textbf{Vincolo di chiave primaria} per l'attributo "CUP".\\
                
                \cline{2-3}
                    & fk\_referente\_scientifico \_progetto
                    & \textbf{Vincolo di chiave esterna} dell'attributo "Referente\_scientifico", il quale fa riferimento all'attributo \textit{chiave primaria}
                    "Matricola" della relazione "DIP\_INDETERMINATO". Se si intende eliminare un dipendente che è un referente scientifico di un progetto,
                    l'azione verrà impedita. Se, invece, si intende aggiornare la matricola, verranno modificate tutte le sue occorrenze.\\ 

                \cline{2-3}
                    & fk\_responsabile\_ progetto 
                    & \textbf{Vincolo di chiave esterna} dell'attributo "Responsabile", il quale fa riferimento all'attributo \textit{chiave primaria}
                    "Matricola" della relazione "DIP\_INDETERMINATO". Se si intende eliminare un dipendente che è un responsabile di un progetto,
                    l'azione verrà impedita. Se, invece, si intende aggiornare la matricola, verranno modificate tutte le sue occorrenze.\\

		        \cline{2-3}
                    & nome\_progetto\_unico
                    & \textbf{Vincolo di unicità} assicura che il valore della colonna "Nome" in ogni riga della tabella sia unico.\\

                \cline{2-3}
                    & check\_positive\_ budget
                    & \textbf{Vincolo di dominio} riguardante l'attributo "Budget", dove si controlla che quest'ultimo
                    non possa essere non positivo (o 0 oppure negativo).\\

                \cline{2-3}
                    & check\_date\_ fine\_inizio
                    & \textbf{Vincolo di dominio} riguardante gli attributi "dataInizio" e "dataFine", dove si controlla che
                    la data di inizio di un progetto non possa essere successiva alla data di fine.\\

                \hline
            \end{tabular}
        \end{center}


        \begin{center}
            \begin{tabular}{|C{2.5cm}|C{3.2cm}|L{9cm}|}
                \hline
                    \textbf{Concetto} & \textbf{Vincolo} & \textbf{Descrizione}\\
                \hline
                    \multirow{3}{2.5cm}[-1.2cm]{\centering LAVORARE (Relazione)}
                    & pk\_lavorare
                    & \textbf{Vincolo di chiave primaria} che comprende gli attributi "CUP" e "nomeLab".\\
                    
                \cline{2-3}
                    & fk\_cup\_lavorare
                    & \textbf{Vincolo di chiave esterna} dell'attributo "CUP", il quale fa riferimento all'attributo \textit{chiave primaria} "CUP" della relazione "PROGETTO".
                    Se si intende eliminare un progetto, allora verranno eliminati anche tutti i rapporti di lavoro dei laboratori per quel progetto. Se, invece, si intende aggiornare il CUP, verranno modificate tutte le sue occorrenze.\\

                \cline{2-3}
                    & fk\_nome\_lavorare
                    & \textbf{Vincolo di chiave esterna} dell'attributo "nomeLab", il quale fa riferimento all'attributo \textit{chiave primaria} "Nome" della relazione "LABORATORIO".
                    Se si intende eliminare un laboratorio, allora verranno eliminati anche tutti i rapporti di lavoro del laboratori per i progetti a lui corrispondenti. Se, invece, si intende modificare il nome del laboratorio, verranno modificate anche tutte le sue occorrenze.\\
                
                \hline
                    \multirow{3}{2.5cm}[-1.2cm]{\centering ATTREZ- ZATURA (Relazione)}
                    & pk\_attrezzatura
                    & \textbf{Vincolo di primaria} per l'attributo "idAttrezzatura".\\
                    
                \cline{2-3}
                    & fk\_nome\_attrezzatura
                    & \textbf{Vincolo di chiave esterna} dell'attributo "nomeLab", il quale fa riferimento all'attributo \textit{chiave primaria} "Nome" della relazione "LABORATORIO".
                    Se si intende eliminare un laboratorio, allora la chiave esterna verrà modificata a NULL, poichè si vuole lasciare intatto lo storico degli acquisti fatti per un progetto. Se, invece, si intende modificare il nome del laboratorio che le contiene, verranno modificate tutte le sue occorrenze.\\

                \cline{2-3}
                    & fk\_cup\_attrezzatura 
                    & \textbf{Vincolo di chiave esterna} dell'attributo "CUP", il quale fa riferimento all'attributo \textit{chiave primaria} "CUP" della relazione "PROGETTO".
                    Se si intende eliminare un progetto, allora verranno eliminate tutte le attrezzature acquistate per quel progetto. Se, invece, si intende aggiornare il CUP, verranno modificate tutte le sue occorrenze.\\
                    
                \hline
                    \multirow{3}{2.5cm}[-1.2cm]{\centering DIP\_PROGET- TO (Relazione)}
                    & pk\_dip\_progetto
                    & \textbf{Vincolo di chiave primaria} per l'attributo "Matricola".\\
                    
                \cline{2-3}
                    & fk\_cup\_dip\_progetto
                    & \textbf{Vincolo di chiave esterna} dell'attributo "CUP", il quale fa riferimento all'attributo \textit{chiave primaria} "CUP" della relazione "PROGETTO".
                    Se si intende eliminare un progetto, allora verranno eliminati anche tutti i contratti a progetto acquistati da esso. Se, invece, si intende aggiornare il CUP, verranno modificate tutte le sue occorrenze.\\

                \cline{2-3}
                    & check\_ordine\_date\_dp 
                    & \textbf{Vincolo di dominio} riguardante gli attributi "dataNascita", "dataAssunzione" e "Scadenza", dove si impedisce di inserire un dipendente
                    assunto prima della data di nascita o con data di scadenza del contratto antecedente alla data di assunzione.\\

                \hline
            \end{tabular}
        \end{center}

\newpage

        


\newpage
    \section{Creazione viste}

        \subsection{FondiRimanentiProgetto}
        La view "FondiRimanentiProgetto" consente di visualizzare i fondi rimanenti per ogni progetto dell'azienda, nonché la suddivisione di questi fondi tra attrezzature e contratti, così da poter visualizzare il budget rimanente per queste categorie di acquisti.\\
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.FondiRimanentiProgetto AS
                        \item SELECT          
                        \begin{description}
                            \item p.CUP,
                            \item p.Nome,
                            \item (p.Budget - p.costoAttrezzature - p.costoContrattiProgetto) AS Fondi\_Rimanenti\_Progetto,
                            \item (p.Budget / 2) - (p.costoAttrezzature) AS Fondi\_Rimanenti\_Attrezzature,
                            \item (p.Budget / 2) - (p.costoContrattiProgetto) AS Fondi\_Rimanenti\_Contratti
                        \end{description}
                        \item FROM\\
                        \item azienda.PROGETTO AS p;
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{dip\_indeterminato\_attuale}
        La view "dip\_indeterminato\_attuale" è progettata per mostrare solo le informazioni dei dipendenti a tempo indeterminato attualmente in servizio, basandosi sulla tabella "dip\_indeterminato".
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.dip\_indeterminato\_attuale AS
                        \item SELECT *        
                        \item FROM azienda.dip\_indeterminato AS DI
                        \item WHERE DI.DataFine IS NULL OR DI.DataFine \(>\) CURRENT\_DATE;
                    \end{description}
                \end{flushleft}
         \normalfont

        \subsection{scatto\_carriera\_attuale}
        La view "scatto\_carriera\_attuale" permette di visionare gli scatti di carriera dei dipendenti attualmente assunti dall'azienda.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.scatto\_carriera\_attuale AS
                        \item SELECT *      
                        \item FROM azienda.scatto\_carriera AS SC
                        \item WHERE SC.matricola IN (
                        \begin{description}
                            \item SELECT DI.matricola
                            \item FROM azienda.dip\_indeterminato AS DI
                            \item WHERE DI.DataFine IS NULL OR DI.DataFine \(>\) CURRENT\_DATE;
                        \end{description}
                        );
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{progetto\_attuale}
        La view "progetto\_attuale" rappresenta una tabella che mostra i progetti dell'azienda non ancora terminati. 
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.progetto\_attuale AS
                        \item SELECT *       
                        \item FROM azienda.progetto AS P
                        \item WHERE P.DataFine >= now() OR P.DataFine IS NULL;
                    \end{description}
                \end{flushleft}
            \normalfont

        \subsection{lavorare\_attuale  }
        La view "lavorare\_attuale" restituisce le informazioni sui laboratori che lavorano attualmente ai progetti che sono ancora in corso o non hanno ancora una data di fine definita.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.lavorare\_attuale AS
                        \item SELECT *       
                        \item FROM azienda.lavorare AS LAV
                        \item WHERE LAV.CUP IN (
                        \begin{description}
                            \item SELECT CUP
                            \item FROM azienda.progetto AS P
                            \item P.DataFine >= now() OR P.DataFine IS NULL
                        \end{description}
                    );
                \end{description}
            \end{flushleft}
        \normalfont


        \subsection{attrezzatura\_attuale}
        La view "attrezzatura\_attuale" mostrerà solo le attrezzature che sono attualmente assegnate ad un laboratorio, escludendo quelle che non sono assegnate a nessun laboratorio.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE VIEW azienda.attrezzatura\_attuale AS
                    \item SELECT *       
                    \item FROM azienda.attrezzatura
                    \item WHERE nomeLab IS NOT NULL;
                \end{description}
            \end{flushleft}
        \normalfont

        \subsection{dip\_progetto\_attuale}
        La view "dip\_progetto\_attuale" mostrerà solo i dipendenti assunti con contratto a progetto che lavorano a progetti attivi e il cui contratto è ancora in corso di validità.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.dip\_progetto\_attuale AS
                        \item SELECT DP.Matricola, DP.Nome, DP.Cognome, DP.codFiscale, DP.Indirizzo, DP.dataNascita, DP.dataAssunzione, DP.Costo, DP.Scadenza, DP.CUP      
                        \item FROM azienda.dip\_progetto AS DP JOIN azienda.progetto AS P ON DP.CUP = P.CUP
                        \item WHERE (P.DataFine >= now() OR P.DataFine IS NULL) AND DP.Scadenza >= now();
                    \end{description}
                \end{flushleft}
            \normalfont


	\subsection{ProgettiLab}
        La view "ProgettiLab" mostrerà i progetti ai quali lavorano meno di 3 laboratori, a cui quindi è possibile assegnarne uno nuovo.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE VIEW azienda.Progettilab AS
                        \item SELECT CUP, COUNT(*) AS "nLab lavoranti"
                        \item FROM azienda.LAVORARE
                        \item GROUP BY CUP
                        \item HAVING COUNT(*) < 3;
                    \end{description}
                \end{flushleft}
            \normalfont

\newpage

    \section{Creazione funzioni}
                
        \subsection{get\_list\_CUP\_referente\_scientifico}
        La funzione "get\_list\_CUP\_referente\_scientifico" restituisce una stringa contenente un elenco di CUP (Codice Unico di Progetto) ai quali un determinato referente scientifico (identificato dalla matricola presa in input) è assegnato.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE FUNCTION azienda.get\_list\_CUP\_referente\_scientifico(matricola IN azienda.matricola) 
                        \item RETURNS TEXT      
                        \item AS
                        \item \$\$
                        \item DECLARE
                        \begin{description}
                            \item progettiCoinvolti CURSOR FOR
                            \begin{description}
                                \item SELECT CUP
                                \item FROM azienda.progetto
                                \item WHERE Referente\_Scientifico = matricola AND (dataFine IS NULL OR dataFine >= current\_date);
                            \end{description}
                            \item cup\_progetto azienda.CUP;
                            \item lista\_referente\_scientifico TEXT := '';
                        \end{description}
                        \item BEGIN 
                            \begin{description}
                                \item OPEN progettiCoinvolti;
                                \item LOOP
                                \begin{description}
                                    \item FETCH progettiCoinvolti INTO cup\_progetto;
                                    \item EXIT WHEN NOT FOUND;
                                    \item lista\_referente\_scientifico = CONCAT (lista\_referente\_scientifico, cup\_progetto || ', ');
                                \end{description}
                                \item END LOOP;
                                \item CLOSE progettiCoinvolti;
                                \item IF lista\_referente\_scientifico <> '' THEN
                                \begin{description}
                                    \item lista\_referente\_scientifico = SUBSTR(lista\_referente\_scientifico, 1, LENGTH(lista\_referente\_scientifico)-2);
                                \end{description}
                                \item END IF;
                                \item RETURN lista\_referente\_scientifico;
                            \end{description}
                        \item END;
                        \item \$\$
                        \item LANGUAGE plpgsql;
                    \end{description}
                \end{flushleft}
            \normalfont




        \subsection{get\_list\_CUP\_responsabile\_progetto}
        La funzione "get\_list\_CUP\_responsabile\_progetto" restituisce una stringa contenente un elenco di CUP (Codice Unico di Progetto) ai quali un determinato responsabile di un progetto (identificato dalla matricola presa in input) è assegnato.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE FUNCTION azienda.get\_list\_CUP\_responsabile\_progetto(matricola IN azienda.matricola) 
                        \item RETURNS TEXT      
                        \item AS
                        \item \$\$
                        \item DECLARE
                        \begin{description}
                            \item progettiCoinvolti CURSOR FOR
                            \begin{description}
                                \item SELECT CUP
                                \item FROM azienda.progetto
                                \item WHERE Responsabile = matricola AND (dataFine IS NULL OR dataFine >= current\_date);
                            \end{description}
                            \item cup\_progetto azienda.CUP;
                            \item lista\_responsabile TEXT := '';
                        \end{description}
                        \item BEGIN 
                            \begin{description}
                                \item OPEN progettiCoinvolti;
                                \item LOOP
                                
                                \begin{description}
                                    \item FETCH progettiCoinvolti INTO cup\_progetto;
                                    \item EXIT WHEN NOT FOUND;
                                    \item lista\_responsabile = CONCAT (lista\_responsabile, cup\_progetto || ', ');
                                \end{description}
                                \item END LOOP;
                                \item CLOSE progettiCoinvolti;
                                
                                \vspace{0.5cm}

                                \item IF lista\_responsabile <> '' THEN
                                \begin{description}
                                    \item lista\_responsabile = SUBSTR(lista\_responsabile, 1, LENGTH(lista\_responsabile)-2);
                                \end{description}
                                \item END IF;
                                
                                \item RETURN lista\_responsabile;
                            \end{description}
                        \item END;
                        \item \$\$
                        \item LANGUAGE plpgsql;
                    \end{description}
                \end{flushleft}
            \normalfont    
    


    
        \subsection{get\_list\_responsabile\_laboratorio}
        La funzione "get\_list\_responsabile\_laboratorio" ha lo scopo di recuperare la lista dei laboratori di cui la matricola inserita come input è il responsabile scientifico.
            \ttfamily
                \begin{flushleft}
                    \begin{description}
                        \item CREATE OR REPLACE FUNCTION azienda.get\_list\_responsabile\_laboratorio(matricola IN azienda.matricola) 
                        \item RETURNS TEXT      
                        \item AS
                        \item \$\$
                        \item DECLARE
                        \begin{description}
                            \item laboratoriCoinvolti CURSOR FOR
                            \begin{description}
                                \item SELECT Nome
                                \item FROM azienda.laboratorio
                                \item WHERE Responsabile\_Scientifico = matricola;
                            \end{description}
                            \item lab azienda.laboratorio.nome\%TYPE;
                            \item lista\_responsabile\_scientifico TEXT := '';
                        \end{description}
                        \item BEGIN 
                            \begin{description}
                                \item OPEN laboratoriCoinvolti;
                                \item LOOP
                                
                                \begin{description}
                                    \item FETCH laboratoriCoinvolti INTO lab;
                                    \item EXIT WHEN NOT FOUND;
                                    \item lista\_responsabile\_scientifico = CONCAT (lista\_responsabile\_scientifico, lab || ', ');
                                \end{description}
                                \item END LOOP;
                                \item CLOSE laboratoriCoinvolti;

                                \item IF lista\_responsabile\_scientifico <> '' THEN
                                \begin{description}
                                    \item lista\_responsabile\_scientifico = SUBSTR(lista\_responsabile\_scientifico, 1, LENGTH(lista\_responsabile\_scientifico)-2);
                                \end{description}
                                \item END IF;
                                \item RETURN lista\_responsabile\_scientifico;
                            \end{description}

                        \item END;
                        \item \$\$
                        \item LANGUAGE plpgsql;
                    \end{description}
                \end{flushleft}
            \normalfont    
    
    
    

            \subsection{aggiorna\_tipo}
            La funzione "aggiorna\_tipo" aggiorna il tipo di un dipendente a tempo indeterminato in base alla differenza di anni tra la data di assunzione e la data di fine (se presente) o la data attuale.\\
            Se la differenza di anni è inferiore a 3, il tipo del dipendente viene impostato a Junior; se è compresa tra 3 e 7 anni, il tipo viene impostato a Middle; se è superiore a 7 anni, il tipo viene impostato a Senior.
                \ttfamily
                    \begin{flushleft}
                        \begin{description}
                            \item CREATE OR REPLACE FUNCTION azienda.aggiorna\_tipo(
                            \begin{description}
                                \item mat IN azienda.dip\_indeterminato.matricola\%TYPE,
                                \item tipo\_mat IN azienda.dip\_indeterminato.tipo\%TYPE,
                                \item dataAssunzione\_mat IN azienda.dip\_indeterminato.dataAssunzione\%TYPE,
                                \item dataFine\_mat IN azienda.dip\_indeterminato.dataFine\%TYPE
                            \end{description}
                            ) 
                            \item RETURNS azienda.dip\_indeterminato.tipo\%TYPE      
                            \item AS
                            \item \$\$
                            \item DECLARE
                            \begin{description}
                                \item check\_existance azienda.dip\_indeterminato.matricola\%TYPE;
                                \item numero\_anni\_trascorsi INTEGER := DATE\_PART('year', AGE(COALESCE(dataFine\_mat, CURRENT\_DATE), dataAssunzione\_mat));
                            \end{description}
                            \item BEGIN 
                                \begin{description}
                                    \item SELECT Matricola INTO check\_existance
                                    \item FROM azienda.dip\_indeterminato
                                    \item WHERE Matricola = mat AND Tipo = tipo\_mat AND dataAssunzione = dataAssunzione\_mat AND dataFine IS NOT DISTINCT FROM dataFine\_mat;
                                    
                                    \item IF NOT FOUND THEN
                                    \begin{description}
                                        \item IF tipo\_mat IS NULL OR dataAssunzione\_mat IS NULL THEN
                                        \begin{description}
                                            \item RAISE EXCEPTION 'Matricola \% non esistente!', mat;
                                        \end{description}
                                        \item ELSE
                                        \begin{description}
                                            \item RAISE EXCEPTION 'Matricola \% di tipo \% e assunto in data \% non esistente!', mat, tipo\_mat, dataAssunzione\_mat;
                                        \end{description}
                                        \item END IF;
                                    \end{description}
                                    \item END IF;
                                        
                                        \item IF numero\_anni\_trascorsi < 3 THEN
                                        \begin{description}
                                            \item IF tipo\_mat = 'Middle' OR tipo\_mat = 'Senior' THEN
                                            \begin{description}
                                                \item RAISE NOTICE La matricola \%\ \`e di tipo ``\%'' anche se non ha trascorso 3 anni in azienda! Cambio il tipo in ``Junior''', mat, tipo\_mat;
                                            \end{description}
                                            \item END IF;
                                            \item tipo\_mat = 'Junior';
                                        \end{description}

                                        \item ELSIF 3 <= numero\_anni\_trascorsi AND numero\_anni\_trascorsi < 7 THEN
                                        \begin{description}
                                            \item IF tipo\_mat = 'Junior' THEN
                                            \begin{description}
                                                \item RAISE NOTICE 'La matricola \% \`e di tipo ''Junior'' ma ha trascorso pi\`u di 3 anni in azienda! Cambio il tipo in ''Middle''', mat;
                                            \end{description}
                                            \item ELSIF tipo\_mat = 'Senior' THEN
                                             \begin{description}
                                                \item RAISE NOTICE 'La matricola \% \`e di tipo ''Senior'' anche se non ha trascorso 7 anni in azienda! Cambio il tipo in ''Middle''', mat;
                                            \end{description}
                                            \item END IF;
                                            \item tipo\_mat = 'Middle';
                                        \end{description}

                                        \item ELSIF numero\_anni\_trascorsi >= 7 THEN
                                        \begin{description}
                                            \item IF tipo\_mat <> 'Senior' THEN
                                            \begin{description}
                                                \item RAISE NOTICE 'La matricola \%\ \`e di tipo ''\%'' ma ha trascorso pi\`u di 7 anni in azienda! Cambio il tipo in ''Senior''', mat, tipo\_mat;    
                                            \end{description}
                                            \item END IF;
                                            \item tipo\_mat = 'Senior';
                                        \end{description}
                                            
                                        \item END IF;
                                        \item RETURN tipo\_mat;                                   
                                \end{description}
                            \item END;
                            \item \$\$
                            \item LANGUAGE plpgsql;
                        \end{description}
                    \end{flushleft}
                \normalfont  
    
\newpage
    
                \subsection{get\_list\_lab\_afferenza\_matricola}
                La funzione "get\_list\_lab\_afferenza\_matricola" ha lo scopo di restituire i nomi di tutti i laboratori a cui afferisce una determinata matricola.
                    \ttfamily
                        \begin{flushleft}
                            \begin{description}
                                \item CREATE OR REPLACE FUNCTION azienda.get\_list\_lab\_afferenza\_matricola(dip\_matricola IN azienda.Matricola)
                                \item RETURNS TEXT     
                                \item AS
                                \item \$\$
                                \item DECLARE
                                \begin{description}
                                    \item var RECORD;
                                    \item lista\_nomiLab text := '';
                                \end{description}
                                \item BEGIN 
                                \begin{description}
                                    \item FOR var IN
                                    \begin{description}
                                        \item SELECT nomeLab
                                        \item FROM azienda.AFFERIRE
                                        \item WHERE Matricola = dip\_matricola
                                    \end{description}
                                    \item LOOP
                                    \begin{description}

                                        \item IF LENGTH(lista\_nomiLab) = 0 THEN
                                        \begin{description}
                                            \item lista\_nomiLab := var.nomeLab;
                                        \end{description}

                                        \item ELSE
                                        \begin{description}
                                            \item lista\_nomiLab := CONCAT(lista\_nomiLab, ', ', var.nomeLab);
                                        \end{description}
                                            
                                        \item END IF;
                                    \end{description}
                                    \item END LOOP;
                                    \item RETURN lista\_nomiLab;
                                \end{description}
                                \item END;
                                \item \$\$
                                \item LANGUAGE plpgsql;
                            \end{description}
                        \end{flushleft}
                    \normalfont  

\newpage

    \section{Creazione procedure}

        \subsection{sostituisci\_referente\_scientifico}
        La procedura "sostituisci\_referente\_scientifico" sostituisce il referente scientifico di uno o più progetti, identificati dal CUP, con una nuova matricola fornita in input.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.sostituisci\_referente\_scientifico(listaCUP IN TEXT, matricola IN azienda.matricola)   
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item copyListaCUP TEXT := listaCUP;
                        \item singleCUP azienda.CUP;
                        \item separatoreIndex INT;;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF listaCUP = '' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Non ci sono CUP in input';
                        \end{description}
                        \item END IF;
                        \item separatoreIndex := STRPOS(listaCUP, ', ');
                        
                        \vspace{0.5cm}

                        \item WHILE separatoreIndex <> 0
                        \item LOOP
                        \begin{description}
                            \item singleCUP := SUBSTR(listaCUP, 1, separatoreIndex-1);
                            \item listaCUP := SUBSTR(listaCUP, separatoreIndex+2, LENGTH(listaCUP));
                            
                            \vspace{0.5cm}

                            \item UPDATE azienda.progetto
                            \item SET Referente\_Scientifico = matricola
                            \item WHERE CUP = singleCUP;
                            
                            \vspace{0.5cm}

                            \item separatoreIndex := STRPOS(listaCUP, ', ');
                        \end{description}
                        \item END LOOP;
                        \item UPDATE azienda.progetto
                        \item SET Referente\_Scientifico = matricola
                        \item WHERE CUP = listaCUP;
                        \item RAISE NOTICE 'Ho sostituito il Referente scientifico dei progetti: \% con la matricola ''\%''', copyListaCUP, matricola;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont             

        \subsection{sostituisci\_responsabile\_progetto}
        La procedura "sostituisci\_responsabile\_progetto" sostituisce il Responsabile di uno o più progetti (identificati dalla loro lista di CUP) con un altro dipendente, il cui identificativo di matricola è specificato come parametro di input. 
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.sostituisci\_responsabile\_progetto(listaCUP IN TEXT, matricola IN azienda.matricola)   
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item copyListaCUP TEXT := listaCUP;
                        \item singleCUP azienda.CUP;
                        \item separatoreIndex INT;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF listaCUP = '' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Non ci sono CUP in input';
                        \end{description}
                        \item END IF;
                        \item separatoreIndex := STRPOS(listaCUP, ', ');
                        
                        \vspace{0.5cm}

                        \item WHILE separatoreIndex <> 0
                        \item LOOP
                        \begin{description}
                            \item singleCUP := SUBSTR(listaCUP, 1, separatoreIndex-1);
                            \item listaCUP := SUBSTR(listaCUP, separatoreIndex+2, LENGTH(listaCUP));
                            
                            \vspace{0.5cm}

                            \item UPDATE azienda.progetto
                            \item SET Responsabile = matricola
                            \item WHERE CUP = singleCUP;
                            
                            \vspace{0.5cm}

                            \item separatoreIndex := STRPOS(listaCUP, ', ');
                        \end{description}
                        \item END LOOP;
                        \item UPDATE azienda.progetto
                        \item SET Responsabile = matricola
                        \item WHERE CUP = listaCUP;
                        \item RAISE NOTICE 'Ho sostituito il Responsabile dei progetti: \% con la matricola ''\%''', copyListaCUP, matricola;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont


        \subsection{sostituisci\_responsabile\_laboratorio}
        La procedura "sostituisci\_responsabile\_laboratorio" si occupa di sostituire il Responsabile Scientifico di uno o più laboratori con un altro dipendente, il cui identificativo di matricola è specificato come parametro di input.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.sostituisci\_responsabile\_laboratorio(listaLaboratori IN TEXT, matricola IN azienda.matricola)   
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item copylistaLaboratori TEXT := listaLaboratori;
                        \item lab azienda.laboratorio.nome\%TYPE;
                        \item separatoreIndex INT;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF listaLaboratori = '' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Non ci sono CUP in input';
                        \end{description}
                        \item END IF;
                        \item separatoreIndex := STRPOS(listaLaboratori, ', ');
                        
                        \vspace{0.5cm}

                        \item WHILE separatoreIndex <> 0
                        \item LOOP
                        \begin{description}
                            \item lab := SUBSTR(listaLaboratori, 1, separatoreIndex-1);
                            \item listaLaboratori := SUBSTR(listaLaboratori, separatoreIndex+2, LENGTH(listaLaboratori));
                            
                            \vspace{0.5cm}

                            \item UPDATE azienda.laboratorio
                            \item SET Responsabile\_Scientifico  = matricola
                            \item WHERE nome = lab;
                            
                            \vspace{0.5cm}

                            \item separatoreIndex := STRPOS(listaLaboratori, ', ');
                        \end{description}
                        \item END LOOP;
                        \item UPDATE azienda.laboratorio
                        \item SET Responsabile\_Scientifico = matricola
                        \item WHERE nome = listaLaboratori;
                        \item RAISE NOTICE 'Ho sostituito il Responsabile scientifico dei laboratori: \% con la matricola ''\%''', copylistaLaboratori, matricola;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont


        \subsection{check\_scatto}
        La procedura "check\_scatto" ha lo scopo di registrare gli scatti di carriera di un dipendente indeterminato dell'azienda. Dati in input la  matricola del dipendente, il tipo da verificare e la data di assunzione (necessaria per la corretta registrazione della data dello scatto), la procedura verifica che ci sia coerenza tra il "Tipo" dichiarato in input e gli scatti presenti nella tabella "SCATTO\_CARRIERA". Nel caso in cui non ci sia coerenza, vengono aggiunti gli scatti mancanti. Gli scatti di carriera vengono registrati in date specifiche (dopo 3 anni dalla data di assunzione per lo scatto a "Middle" e dopo 7 anni per lo scatto a "Senior"). 
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.check\_scatto(
                        \begin{description}
                            \item mat IN azienda.dip\_indeterminato.matricola\%TYPE,
                            \item tipo\_mat IN azienda.dip\_indeterminato.tipo\%TYPE,
                            \item dataAssunzione\_mat IN azienda.dip\_indeterminato.dataAssunzione\%TYPE
                        \end{description}
                        )  
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item check\_existance azienda.dip\_indeterminato.matricola\%TYPE;

                        \item cursore CURSOR (test\_tipo TEXT) FOR
                        \begin{description}
                            \item SELECT Data
                            \item FROM azienda.SCATTO\_CARRIERA
                            \item WHERE Matricola = mat AND tipo = test\_tipo;
                        \end{description}
                        \item data\_scatto azienda.scatto\_carriera.data\%TYPE;
                    
                        \item scattiPresenti TEXT := 'Scatti gi\'a registrati:';
                        \item scattiAggiunti TEXT := 'Nuovi scatti registrati:';
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT Matricola INTO check\_existance
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = mat AND UPPER(Tipo) = UPPER(tipo\_mat) AND dataAssunzione = dataAssunzione\_mat;

                        \item IF NOT FOUND THEN
                        \begin{description}
                            \item IF tipo\_mat IS NULL OR dataAssunzione\_mat IS NULL THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'Matricola \% non esistente!', mat;
                            \end{description}
                            \item ELSE
                            \begin{description}
                                \item RAISE EXCEPTION 'Matricola \% di tipo \% e assunto in data \% non esistente!', mat, tipo\_mat, dataAssunzione\_mat;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;
                        \vspace{0.5cm}
                        \item IF UPPER(tipo\_mat) = 'JUNIOR' THEN tipo\_mat = 'Junior';
                        \item ELSIF UPPER(tipo\_mat) = 'MIDDLE' THEN tipo\_mat = 'Middle';
                        \item ELSIF UPPER(tipo\_mat) = 'SENIOR' THEN tipo\_mat = 'Senior';
                        \item ELSE RAISE EXCEPTION 'Tipo non accettato!';
                        \item END IF;
                        
                        \vspace{0.5cm}

                        \item IF tipo\_mat = 'Junior' THEN
                        \begin{description}
                            \item RAISE NOTICE 'La matricola \% è di tipo Junior! Nessuno scatto registrato', mat;
                        \end{description}

                        \item ELSE
                        \begin{description}
                            \item OPEN cursore('Middle');
                            \item FETCH cursore INTO data\_scatto; 

                            \item IF NOT FOUND THEN
                            \begin{description}
                                \item scattiAggiunti := CONCAT (scattiAggiunti, ' "Junior" a "Middle"');
                                \item INSERT INTO azienda.SCATTO\_CARRIERA(Matricola, Tipo, Data) VALUES
                                \item (mat, 'Middle', dataAssunzione\_mat + interval '3 years');
                            \end{description}
                        
                            \item ELSE
                            \begin{description}
                                \item scattiPresenti := CONCAT (scattiPresenti, ' "Junior" a "Middle"');
                            \end{description}
                            \item END IF;
                            \item CLOSE cursore;

                            \vspace{0.5cm}

                            \item IF tipo\_mat = 'Senior' THEN
                            \begin{description}
                                \item OPEN cursore('Senior');
                                \item FETCH cursore INTO data\_scatto; 

                                \item IF NOT FOUND THEN
                                \begin{description}
                                    \item IF scattiAggiunti <> 'Nuovi scatti registrati:' THEN
                                    \begin{description}
                                        \item scattiAggiunti := CONCAT (scattiAggiunti, ' e');
                                    \end{description}
                                    \item END IF;
                                    \item scattiAggiunti := CONCAT (scattiAggiunti, ' "Middle" a "Senior"');
                                        
                                    \item INSERT INTO azienda.SCATTO\_CARRIERA(Matricola, Tipo, Data) VALUES
                                    \item (mat, 'Senior', dataAssunzione\_mat + interval '7 years');
                                \end{description}   
                                \item ELSE 
                                \begin{description}
                                    \item IF scattiPresenti <> 'Scatti già registrati:' THEN
                                    \begin{description}
                                        \item scattiPresenti := CONCAT (scattiPresenti, ' e');
                                    \end{description}
                                    \item END IF;
                                    \item scattiPresenti := CONCAT (scattiPresenti, ' "Middle" a "Senior"');
                                \end{description}
                            \item END IF;
                            \item CLOSE cursore;
                            \end{description}
                            \item END IF;
                            \vspace{0.5cm}
                            \item IF scattiPresenti = 'Scatti già registrati:' THEN
                            \begin{description}
                                \item scattiPresenti := CONCAT(scattiPresenti, ' Nessuno');
                            \end{description}
                            \item END IF;
                            \vspace{0.5cm}
                            \item IF scattiAggiunti = 'Nuovi scatti registrati:' THEN
                            \begin{description}
                                \item scattiAggiunti := CONCAT(scattiAggiunti, ' Nessuno');
                            \end{description}
                            \item END IF;
                            \vspace{0.5cm}
                            \item RAISE NOTICE E'Matricola \%, tipo \%:\textbackslash{n}\% \textbackslash{n}\%', mat, tipo\_mat, scattiPresenti, scattiAggiunti;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

\vspace{3cm}

        \subsection{aggiorna\_tipo\_listaDipendenti}
        La procedura "aggiorna\_tipo\_listaDipendenti" ha lo scopo di aggiornare l'anzianità di una lista di dipendenti passati per input. In particolare, verifica l'anzianità di ogni dipendente sia aggiornata rispetto alla data odierna (o alla data di licenziamento, se presente). Se vi sono dipendenti da aggiornare, li aggiorna.
        Assumiamo che tale procedura venga invocata periodicamente per aggiornare i dipendenti che con il tempo hanno fatto uno scatto di carriera.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.aggiorna\_tipo\_listaDipendenti(listaMatricole IN TEXT)  
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item copyListaMatricole TEXT := listaMatricole;
                        \item dati\_matricola RECORD;
                        \item tipo\_effettivo azienda.dip\_indeterminato.tipo\%TYPE;
                        \item mat azienda.dip\_indeterminato.matricola\%TYPE;
                        \item separatoreIndex INT;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF listaMatricole = '' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Non ci sono matricole in input';
                        \end{description}
                        \item END IF;
                        \item separatoreIndex := STRPOS(listaMatricole, ', ');
                        
                        \vspace{0.5cm}

                        \item WHILE separatoreIndex <> 0
                        \item LOOP
                        \begin{description}
                            \item mat := SUBSTR(listaMatricole, 1, separatoreIndex-1);
                            \item listaMatricole := SUBSTR(listaMatricole, separatoreIndex+2, LENGTH(listaMatricole));
                            
                            \vspace{0.5cm}
                            
                            \item SELECT tipo, dataAssunzione, dataFine INTO dati\_matricola
                            \item FROM azienda.DIP\_INDETERMINATO
                            \item WHERE Matricola = mat;
                            
                            \vspace{0.5cm}
                            
                            \item IF NOT FOUND THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% non esiste', mat;
                                \end{description}
                            \item END IF;

                            \vspace{0.5cm}
                            
                            \item tipo\_effettivo = azienda.aggiorna\_tipo(mat, dati\_matricola.tipo, dati\_matricola.dataAssunzione, dati\_matricola.dataFine);
                            \item IF tipo\_effettivo <> dati\_matricola.tipo THEN
                                \begin{description}
                                    \item UPDATE azienda.DIP\_INDETERMINATO
                                    \item SET Tipo = tipo\_effettivo
                                    \item WHERE Matricola = mat;
                                \end{description}
                            \item END IF;
                    
                            \vspace{0.5cm}

                            \item separatoreIndex := STRPOS(listaMatricole, ', ');
                        \end{description}
                        \item END LOOP;
                        \item SELECT tipo, dataAssunzione, dataFine INTO dati\_matricola
                        \item FROM azienda.DIP\_INDETERMINATO
                        \item WHERE Matricola = listaMatricole;
                        
                        \vspace{0.5cm}
                        
                        \item IF NOT FOUND THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% non esiste', listaMatricole;
                                \end{description}
                            \item END IF;

                            \vspace{0.5cm}
                            
                            \item tipo\_effettivo = azienda.aggiorna\_tipo(listaMatricole, dati\_matricola.tipo, dati\_matricola.dataAssunzione, dati\_matricola.dataFine);
                            \item IF tipo\_effettivo <> dati\_matricola.tipo THEN
                                \begin{description}
                                    \item UPDATE azienda.DIP\_INDETERMINATO
                                    \item SET Tipo = tipo\_effettivo
                                    \item WHERE Matricola = listaMatricole;
                                \end{description}
                            \item END IF;

                        \vspace{0.5cm}
                            
                        \item RAISE NOTICE 'Ho aggiornato, dove possibile, l''anzianità per le matricole: \%', copyListaMatricole;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsection{check\_afferenza\_per\_dataFine}
        La procedura "check\_afferenza\_per\_dataFine" ha lo scopo di eliminare tutte le afferenze ai laboratori per i dipendenti a tempo indeterminato della tabella "azienda.DIP\_INDETERMINATO" che hanno una data di fine contratto minore o uguale alla data corrente e che risultano essere ancora afferiti ad almeno un laboratorio nella tabella "azienda.AFFERIRE". Assumiamo che tale procedura venga invocata periodicamente.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE PROCEDURE azienda.check\_afferenza\_per\_dataFine()  
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item lista\_laboratori\_afferiti text;
                        \item var RECORD;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item FOR var IN 
                        \begin{description}
                            \item SELECT DI.Matricola
                            \item FROM azienda.DIP\_INDETERMINATO AS DI
                            \item WHERE DI.dataFine <= DATE(NOW() AND EXISTS
                            \begin{description}
                               \item (SELECT *
                                \item FROM azienda.AFFERIRE AS A
                                \item WHERE A.matricola = DI.Matricola))
                            \end{description}
                        \end{description}
                    
                        \item LOOP
                        \begin{description}
                            \item lista\_laboratori\_afferiti := azienda.get\_list\_lab\_afferenza\_matricola(var.Matricola);
                            \vspace{0.5cm}
                            \item IF lista\_laboratori\_afferiti = '' THEN
                            \begin{description}
                                \item RAISE NOTICE E'Il dipendente a tempo indeterminato \% non afferisce ad alcun laboratorio.\textbackslash{n} Pertanto non è possibile rimuovere alcuna afferenza per quest''ultimo!', var.Matricola;
                            \end{description}

                            \item ELSE
                            \begin{description}
                                \item DELETE FROM azienda.AFFERIRE
                                \item WHERE Matricola = var.Matricola;
                            \end{description}

                            \item RAISE NOTICE E'Sono state eliminate le afferenze ai laboratori "\%" del dipendente a tempo indeterminato "\%"', lista\_laboratori\_afferiti, var.Matricola;
                            \item END IF;
                        \end{description}
                        \item END LOOP;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

    \newpage

    \section{Creazione trigger}
    Di seguito sono riportati tutti i vincoli di integrità semantica, accompagnati da un'apposita descrizione
    
        \subsection{TRIGGERS PER azienda.DIP\_INDETERMINATO}

        \subsubsection{nice\_looking\_domain\_di}
        Il trigger "nice\_looking\_domain\_di" rende il campo "Tipo" di "azienda.DIP\_INDETERMINATO" case insensitive. Il campo "Tipo" avrà sempre la prima lettera maiuscola e le restanti minuscole.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_nice\_looking\_domain\_di()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item NEW.tipo = CONCAT(UPPER(SUBSTR(NEW.tipo, 1, 1)), LOWER(SUBSTR(NEW.Tipo, 2, LENGTH(NEW.Tipo))));
	                    \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER a\_tr\_nice\_looking\_domain\_di
                    \item BEFORE INSERT OR UPDATE OF tipo ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_nice\_looking\_domain\_di();
                \end{description}
            \end{flushleft}
        \normalfont

        \newpage

        \subsubsection{blocco\_modifica\_dirigente}
        Il trigger "blocco\_modifica\_dirigente" impedisce la modifica manuale dello stato dirigenziale dei dipendenti nella tabella "azienda.DIP\_INDETERMINATO". \\
        Viene distinto il caso dell'inserimento da quello dell'aggiornamento del campo "Dirigente". Nel caso dell'inserimento viene impostato automaticamente a FALSE, nel caso dell'update viene ignorata la modifica effettuata. Questo perché la dirigenza viene aggiornata sulla base dello scatto inserito in "azienda.SCATTO\_CARRIERA".
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_blocco\_modifica\_dirigente()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item IF OLD.Matricola IS NULL THEN
                        \begin{description}
                            \item IF (NEW.Dirigente <> FALSE) THEN
                            \begin{description}
                                \item RAISE NOTICE E'Non puoi inserire manualmente lo stato dirigenziale del dipendete \%. E'' necessario inserire l''apposito scatto in "azienda.scatto\_carriera"', NEW.Matricola;
                                \item  NEW.Dirigente = FALSE;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item ELSE
                        \begin{description}
                            \item IF (NEW.Dirigente <> OLD.Dirigente) THEN
                            \begin{description}
                                \item RAISE NOTICE E'Non puoi inserire manualmente lo stato dirigenziale del dipendete \%. E'' necessario inserire l''apposito scatto in "azienda.scatto\_carriera"', NEW.Matricola;
                                \item NEW.Dirigente = OLD.Dirigente;
                            \end{description}
                            END IF;
                        \end{description}
                        \item END IF;
                        
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_blocco\_modifica\_dirigente
                    \item BEFORE INSERT OR UPDATE OF Dirigente ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item WHEN (pg\_trigger\_depth() < 1)
                    \item EXECUTE FUNCTION azienda.fn\_blocco\_modifica\_dirigente();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{verifica\_tipo\_dipInd}
        Il trigger "verifica\_tipo\_dipInd" controlla il tipo di un dipendente in base al numero di anni trascorsi dall'assunzione. In particolare, la funzione controlla se il tipo di un dipendente rispetta i requisiti di anzianità per il ruolo assegnato (Junior, Middle o Senior).
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_verifica\_tipo\_dipInd()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item numero\_anni\_trascorsi INTEGER := DATE\_PART('year', AGE(COALESCE(NEW.dataFine, CURRENT\_DATE), NEW.dataAssunzione));
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                            \item IF numero\_anni\_trascorsi < 3 THEN
                            \begin{description}
                                \item IF NEW.Tipo = 'Middle' OR NEW.Tipo = 'Senior' THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% è di tipo "\%" anche se non ha trascorso 3 anni in azienda!', NEW.matricola, NEW.Tipo;
                                \end{description}
                                \item END IF;
                            \end{description}

                            \item ELSIF 3 <= numero\_anni\_trascorsi AND numero\_anni\_trascorsi < 7 THEN
                            \begin{description}
                                \item IF NEW.Tipo = 'Junior' THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% è di tipo "Junior" ma ha trascorso più di 3 anni in azienda!', NEW.matricola;
                                \end{description}
                                \item ELSIF NEW.Tipo = 'Senior' THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% è di tipo "Senior" anche se non ha trascorso 7 anni in azienda!', NEW.matricola;
                                \end{description}
                                \item END IF;
                            \end{description}
                            
                            \item ELSIF numero\_anni\_trascorsi >= 7 THEN
                            \begin{description}
                                \item IF NEW.Tipo <> 'Senior' THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'La matricola \% è di tipo "\%" ma ha trascorso più di 7 anni in azienda!', NEW.matricola, NEW.Tipo;  
                                \end{description}  
                                \item END IF;
                            \end{description}
            
                            \item END IF;
                            \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_verifica\_tipo\_dipInd
                    \item BEFORE INSERT OR UPDATE ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_verifica\_tipo\_dipInd();
                \end{description}
            \end{flushleft}
        \normalfont

        \newpage
        
        \subsubsection{aggiorna\_scatti\_tipo}
        Il trigger "aggiorna\_scatti\_tipo" aggiorna automaticamente gli scatti di carriera dei dipendenti di un'azienda nel caso in cui vengano inseriti o aggiornati i loro dati nel database. Nel caso in cui il dipendente sia stato promosso o declassato (caso possibile in seguito all'aggiornamento del periodo di attività), la funzione elimina eventuali scatti di carriera superflui e aggiunge quelli mancanti.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_aggiorna\_scatti\_tipo()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                            \item IF OLD.Matricola IS NULL THEN
                            \begin{description}
                                \item CALL azienda.check\_scatto(NEW.Matricola, NEW.Tipo, NEW.dataAssunzione);
                            \end{description}

                            \item ELSE;
                            \begin{description}
                                \item IF NEW.Tipo = 'Junior' AND (OLD.Tipo = 'Middle' OR OLD.Tipo = 'Senior') THEN
                                \begin{description}
                                    \item DELETE FROM azienda.SCATTO\_CARRIERA
                                    \item WHERE Matricola = NEW.Matricola AND (Tipo = 'Middle' OR Tipo = 'Senior');
                                \end{description}

                                \item ELSIF NEW.Tipo = 'Middle' AND (OLD.Tipo = 'Senior') THEN
                                \begin{description}
                                    \item DELETE FROM azienda.SCATTO\_CARRIERA
                                    \item WHERE Matricola = NEW.Matricola AND Tipo = 'Senior';
                                \end{description}
                                \item CALL azienda.check\_scatto(NEW.Matricola, NEW.Tipo, NEW.dataAssunzione);
                            \end{description}
            
                            \item END IF;
                            \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_aggiorna\_scatti\_tipo
                    \item AFTER INSERT OR UPDATE ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_aggiorna\_scatti\_tipo();
                \end{description}
            \end{flushleft}
        \normalfont

    \newpage

        \subsubsection{assunzione\_coerente}
        Il trigger "assunzione\_coerente" verifica se l'assunzione di un dipendente risulta coerente rispetto ad altri contratti di lavoro esistenti. In particolare, controlla se ci sono conflitti tra i periodi di validità dei contratti (inizio e fine), ovvero se ci sono sovrapposizioni o periodi di tempo in cui un dipendente ha due o più contratti contemporaneamente.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_assunzione\_coerente()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                        \begin{description}
                            \item cursore CURSOR FOR
                            \begin{description}
                                \item SELECT DI.Matricola, DI.codFiscale, DI.dataAssunzione, DI.dataFine
                                \item FROM azienda.DIP\_INDETERMINATO DI
                                \item WHERE DI.codFiscale = NEW.codFiscale AND DI.matricola <> NEW.Matricola
                                \item ORDER BY DI.dataAssunzione ASC;
                            \end{description}
                            \item dip\_ind RECORD;
                            \item lista\_contratti TEXT := '';
                        \end{description}
                    \item BEGIN 
                    \begin{description}
                            \item OPEN cursore;
                            \item LOOP

                            \vspace{0.5cm}

                            \begin{description}
                                \item FETCH cursore INTO dip\_ind;
                                \item EXIT WHEN NOT FOUND;
                                \item IF (((dip\_ind.dataFine IS NULL) AND (dip\_ind.Matricola <> NEW.Matricola)) OR\\
                                \item (dip\_ind.dataAssunzione <= NEW.dataAssunzione AND NEW.dataAssunzione < dip\_ind.dataFine) OR\\
                                \item (dip\_ind.dataAssunzione < NEW.dataFine AND NEW.dataFine <= dip\_ind.dataFine) OR\\
                                \item NEW.dataAssunzione < dip\_ind.dataAssunzione AND NEW.dataFine > dip\_ind.dataFine) THEN
                                \begin{description}
                                    \item lista\_contratti := CONCAT(lista\_contratti, dip\_ind.Matricola || ', ');
                                \end{description}
                                \item END IF;
                            \end{description}

                            \item END LOOP;
                            \item CLOSE cursore;
                            \vspace{0.5cm}
                            \item IF lista\_contratti <> '' THEN
                                \begin{description}
                                    \item lista\_contratti := SUBSTR(lista\_contratti, 1, LENGTH(lista\_contratti)-2);
                                    \item RAISE EXCEPTION 'Non è stato possibile stipulare il contratto con matricola \% per \%. \\La persona ha ancora un contratto in corso o vi è un conflitto tra la data di assunzione (o di fine) e i seguenti contratti: \%', NEW.Matricola, NEW.codFiscale, lista\_contratti;
                                \end{description}
                            \item END IF;
                            \vspace{0.5cm}

                            \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER c\_tr\_assunzione\_coerente
                    \item BEFORE INSERT OR UPDATE OF codFiscale, dataAssunzione, dataFine
                    \item ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_assunzione\_coerente();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage
        
        \subsubsection{delete\_dipInd\_afferenze}
        Il trigger "delete\_dipInd\_afferenze" verifica se il valore della colonna "dataFine" è stato modificato, e se la nuova data è antecedente a quella corrente, elimina tutte le tuple correlate all'impiegato nella tabella "AFFERIRE". In caso contrario, la funzione mantiene le afferenze sino alla data specificata.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_delete\_dipInd\_afferenze()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item IF NEW.dataFine <= DATE(NOW()) THEN
                        \begin{description}
                            \item DELETE FROM azienda.AFFERIRE
                            \item WHERE Matricola = OLD.Matricola;
                    
                            \item RAISE NOTICE 'Eliminate tutte le afferenze della matricola \% non più attiva!', OLD.Matricola;
                        \end{description}

                        \item ELSE
                        \begin{description}
                            \item RAISE NOTICE 'Siccome la dataFine inserita \% è successiva rispetto la data corrente \%, verranno mantenute tutte le afferenze semplici ai laboratori.',NEW.dataFine, DATE(NOW());
                        \end{description}

                        \item END IF;
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_delete\_dipInd\_afferenze
                    \item AFTER UPDATE OF dataFine ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item WHEN (OLD.dataFine IS DISTINCT FROM NEW.DataFine AND NEW.dataFine IS NOT NULL)
                    \item EXECUTE FUNCTION azienda.fn\_delete\_dipInd\_afferenze();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{licenzia\_dipInd\_con\_incarichi}
        Il trigger "licenzia\_dipInd\_con\_incarichi" ha l'obiettivo di impedire il licenziamento (o la modifica del tipo o della dirigenza) di un dipendente dell'azienda che ricopre il ruolo di Referente scientifico o di Responsabile di progetti attivi o che ricopre il ruolo di Responsabile scientifico di un laboratorio.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_licenzia\_dipInd\_con\_incarichi()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item lista\_responsabile TEXT := azienda.get\_list\_CUP\_responsabile\_progetto(NEW.matricola);
                        \item lista\_referente\_scientifico TEXT := azienda.get\_list\_CUP\_referente\_scientifico(NEW.matricola);
                        \item lista\_responsabile\_scientifico TEXT := azienda.get\_list\_responsabile\_laboratorio(NEW.matricola);
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF (OLD.Tipo <> NEW.Tipo) OR (NEW.DataFine IS NOT NULL) THEN
                        \begin{description}
                            \item IF lista\_referente\_scientifico <> '' THEN
                            \begin{description}
                                \item RAISE EXCEPTION E'Impossibile licenziare il dipendente (o modificarne il tipo) con matricola \% perchè è ancora Referente scientifico in alcuni progetti attivi. \textbackslash{n} \\Sostituisci prima il Referente scientifico (è possibile farlo tramite la procedura "azienda.sostituisci\_referente\_scientifico (azienda.get\_list\_CUP\_referente\_scientifico (<vecchiaMatricola>), <nuovaMatricola> )", che sostituirà tutte le vecchie occorrenze del referente scientifico con la nuova matricola) e poi potrai procedere con il licenziamento.\textbackslash{n} I progetti in questione sono: \%', NEW.Matricola, lista\_referente\_scientifico;
                            \end{description}
                            \item END IF;

                            \item IF lista\_responsabile\_scientifico <> '' THEN
                            \begin{description}
                                \item RAISE EXCEPTION E'Impossibile licenziare il dipendente (o modificarne il tipo) con matricola \% perchè è ancora Responsabile scientifico in alcuni laboratori.\textbackslash{n}\\Sostituisci prima il Responsabile scientifico (è possibile farlo tramite la procedura "azienda.sostituisci\_responsabile\_laboratorio (azienda.get\_list\_responsabile\_laboratorio (<vecchiaMatricola>), <nuovaMatricola>)", che sostituirà tutte le vecchie occorrenze del responsabile scientifico con la nuova matricola) e poi potrai procedere con il licenziamento.\textbackslash{n}I laboratori in questione sono: \%', NEW.Matricola, lista\_responsabile\_scientifico;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;

                        \vspace{0.5cm}

                        \item IF (OLD.Dirigente <> NEW.Dirigente) OR (NEW.DataFine IS NOT NULL) THEN
                        \begin{description}
                            \item IF lista\_responsabile <> '' THEN
                            \begin{description}
                                \item RAISE EXCEPTION E'Impossibile licenziare il dipendente (o modificarne la dirigenza) con matricola \% perchè è ancora Responsabile in alcuni progetti attivi.\textbackslash{n} \\Sostituisci prima il Responsabile (è possibile farlo tramite la procedura "azienda.sostituisci\_responsabile\_progetto (azienda.get\_list\_CUP\_responsabile\_progetto (<vecchiaMatricola>), <nuovaMatricola> )", che sostituirà tutte le vecchie occorrenze del responsabile con la nuova matricola) e poi potrai procedere con il licenziamento.\textbackslash{n} I progetti in questione sono: \%', NEW.Matricola, lista\_responsabile;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;
                        
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER c\_tr\_licenzia\_dipInd\_con\_incarichi
                    \item BEFORE UPDATE ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item WHEN (
                    \begin{description}
                        \item OLD.dataFine IS DISTINCT FROM NEW.dataFine OR
                        \item OLD.Tipo <> NEW.Tipo OR
                        \item OLD.Dirigente <> NEW.Dirigente
                    \end{description}
                    \item )
                    \item EXECUTE FUNCTION azienda.fn\_licenzia\_dipInd\_con\_incarichi();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage
        
    \subsection{TRIGGERS PER azienda.SCATTO\_CARRIERA}


        \subsubsection{nice\_looking\_domain\_sc}
        Il trigger "nice\_looking\_domain\_sc" rende il campo "Tipo" di "azienda.SCATTO\_CARRIERA" case insensitive. Il campo "Tipo" avrà sempre la prima lettera maiuscola e le restanti minuscole.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_nice\_looking\_domain\_sc()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item NEW.tipo = CONCAT(UPPER(SUBSTR(NEW.tipo, 1, 1)), LOWER(SUBSTR(NEW.Tipo, 2, LENGTH(NEW.Tipo))));

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER a\_tr\_nice\_looking\_domain\_sc
                    \item BEFORE INSERT OR UPDATE OF tipo ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_nice\_looking\_domain\_sc();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{verifica\_scatto\_tipo\_IU (INSERT \& UPDATE)}
        Il trigger "verifica\_scatto\_tipo\_IU" controlla se lo scatto che si intende inserire (o modificare) rispetti la data esatta in cui dovrebbe avvenire e che il "Tipo" dello scatto in esame sia plausibile rispetto al "Tipo" del dipendente in "DIP\_INDETERMINATO". Si noti che viene anche verificato che la matricola inserita effettivamente esista. Questo ha il solo scopo di generare un messaggio di errore personalizzato, dato che tale vincolo è verificato già dal vincolo di chiave esterna.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_verifica\_scatto\_tipo\_IU()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item dati\_matricola RECORD;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT Tipo, dataAssunzione INTO dati\_matricola
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = NEW.Matricola;
                        \vspace{0.5cm}
                        \item IF NOT FOUND THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Matricola \% non esistente', NEW.Matricola;
                        \end{description}
                        \item END IF;

                        \vspace{0.5cm}

                        \item IF NEW.Tipo = 'Middle' AND dati\_matricola.Tipo = 'Junior' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'La matricola \% è "Junior"! Impossibile registrare lo scatto da "Junior" a "Middle"', NEW.Matricola;
                        \end{description}
                        \item END IF;

                        \vspace{0.5cm}

                        \item IF NEW.Tipo = 'Middle' AND NEW.Data <> CAST(dati\_matricola.dataAssunzione + interval '3 years' AS DATE) THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Per la matricola \%, lo scatto da "Junior" a "Middle" deve essere in data \%!', NEW.Matricola, CAST(dati\_matricola.dataAssunzione + interval '3 years' AS DATE);
                        \end{description}
                        \item END IF;

                        \vspace{0.5cm}

                        \item IF NEW.Tipo = 'Senior' AND (dati\_matricola.Tipo = 'Middle' OR dati\_matricola.Tipo = 'Junior') THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'La matricola \% è "Middle"! Impossibile registrare lo scatto da "Middle" a "Senior"', NEW.Matricola;
                        \end{description}
                        \item END IF;
                        
                        \vspace{0.5cm}

                        \item IF NEW.Tipo = 'Senior' AND NEW.Data <> CAST(dati\_matricola.dataAssunzione + interval '7 years' AS DATE) THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Per la matricola \%, lo scatto da "Middle" a "Senior" deve essere in data \%!', NEW.Matricola, CAST(dati\_matricola.dataAssunzione + interval '7 years' AS DATE);
                        \end{description}
                        \item END IF;

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_verifica\_scatto\_tipo\_IU
                    \item BEFORE INSERT OR UPDATE ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item WHEN (NEW.Tipo = 'Middle' OR NEW.Tipo = 'Senior')
                    \item EXECUTE FUNCTION azienda.fn\_verifica\_scatto\_tipo\_IU();
                \end{description}
            \end{flushleft}
        \normalfont


        \subsubsection{verifica\_scatto\_tipo\_D (DELETE)}
        Il trigger "verifica\_scatto\_tipo\_D" ha il compito di verificare se è possibile eliminare uno scatto di carriera in base alla tipologia dell'impiegato e alla tipologia di scatto che si vuole eliminare. 
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_verifica\_scatto\_tipo\_D()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item dati\_matricola RECORD;
                        \item numero\_anni\_trascorsi INTEGER := 0;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT Tipo INTO dati\_matricola
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = OLD.Matricola;
                        
                        \vspace{0.5cm}

                        \item IF OLD.Tipo = 'Senior' AND dati\_matricola.Tipo = 'Senior' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'La matricola \% è "Senior"! Impossibile eliminare lo scatto da "Middle" a "Senior"', OLD.Matricola;
                        \end{description}
                        \item END IF;

                        \vspace{0.5cm}

                        \item IF OLD.Tipo = 'Middle' AND (dati\_matricola.Tipo = 'Middle' OR dati\_matricola.Tipo = 'Senior') THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'La matricola \% è "\%"! Impossibile eliminare lo scatto da "Junior" a "Middle"', OLD.Matricola, dati\_matricola.Tipo;
                        \end{description}
                        \item END IF;

                        \item RETURN OLD;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_verifica\_scatto\_tipo\_D
                    \item BEFORE DELETE ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item WHEN (OLD.Tipo = 'Middle' OR OLD.Tipo = 'Senior')
                    \item EXECUTE FUNCTION azienda.fn\_verifica\_scatto\_tipo\_D();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{verifica\_scatto\_dirigente\_IU (INSERT \& UPDATE)}
        Il trigger "verifica\_scatto\_dirigente\_IU" ha lo scopo di verificare la correttezza dell'operazione di inserimento o aggiornamento di uno scatto dirigenziale all'interno della tabella "azienda.SCATTO\_CARRIERA".\\
        Controlla la correttezza dell'operazione sulla base di alcune regole, tra cui la coerenza della data dello scatto con la data di inizio e fine del periodo di servizio del dipendente, la corretta sequenza degli scatti dirigenziali e la non molteplicità di più scatti dirigenziali per lo stesso dipendente in una stessa data. Si noti che viene anche verificato che la matricola inserita effettivamente esista. Questo ha il solo scopo di generare un messaggio di errore personalizzato, dato che tale vincolo è verificato già dal vincolo di chiave esterna.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_verifica\_scatto\_dirigente\_IU()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                        \begin{description}
                            \item cursore\_nuova\_matricola CURSOR FOR
                            \begin{description}
                                \item SELECT Tipo, Data
                                \item FROM azienda.scatto\_carriera
                                \item WHERE Matricola = NEW.Matricola AND (Tipo = 'Rimosso da dirigente' OR Tipo = 'Promosso a dirigente')
                                \item ORDER BY Data ASC;         
                            \end{description}

                            \vspace{0.5cm}

                            \item cursore\_vecchia\_matricola CURSOR FOR
                            \begin{description}
                                \item SELECT Tipo, Data
                                \item FROM azienda.scatto\_carriera
                                \item WHERE Matricola = OLD.Matricola AND (Tipo = 'Rimosso da dirigente' OR Tipo = 'Promosso a dirigente')
                                \item ORDER BY Data ASC;
                            \end{description}

                            \item scatto\_attuale RECORD;
                            \item scatto\_precedente RECORD;
                            
                            \vspace{0.5cm}

                            \item dati\_matricola RECORD;
                            \item looped BOOLEAN := FALSE;
                        \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT dataAssunzione, dataFine, Dirigente INTO dati\_matricola
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = NEW.Matricola;
                        
                        \vspace{0.5cm}
                        
                        \item  IF NOT FOUND THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Matricola \% non esistente', NEW.Matricola;
                        \end{description}
                        \item END IF;
                        
                        \item  IF OLD.Matricola IS NOT NULL AND NEW.Matricola <> OLD.Matricola THEN
                        \begin{description}
                            \item  OPEN cursore\_vecchia\_matricola;
                            \item FETCH cursore\_vecchia\_matricola INTO scatto\_precedente;

                            \item  IF FOUND THEN
                            \begin{description}

                                \item  IF scatto\_precedente.Tipo <> 'Promosso a dirigente' THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'Cambiando lo scatto di \%, il primo scatto risulta essere "Rimosso da dirigente"', OLD.Matricola;
                                \end{description}
                                \item END IF;
                                
                                \vspace{0.5cm}
                                
                                \item LOOP
                                \begin{description}
                                    \item FETCH cursore\_vecchia\_matricola INTO scatto\_attuale;
                                    \item EXIT WHEN NOT FOUND;
                                    
                                    \vspace{0.5cm}
                                    
                                    \item IF scatto\_precedente.Tipo = scatto\_attuale.Tipo THEN
                                    \begin{description}
                                        \item RAISE EXCEPTION 'Lo scatto in data \% è uguale a quello in data \% per la matricola \%', scatto\_precedente.Data, scatto\_attuale.Tipo, OLD.Matricola;
                                    \end{description}
                                    \item END IF;
                                    
                                    \vspace{0.5cm}
                                    
                                    \item scatto\_precedente = scatto\_attuale; 
                                \end{description}
                                \item END LOOP;
                            \end{description}
                            \item END IF;
                            \item CLOSE cursore\_vecchia\_matricola;
                        \end{description}
                        \item END IF;

                        \item  IF dati\_matricola.dataFine IS NULL THEN
                        \begin{description}
                            \item  IF NEW.Data < dati\_matricola.dataAssunzione THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'La matricola \% non può essere dirigente (o essere rimosso da dirigente) prima di essere assunta!', NEW.Matricola;
                            \end{description}
                            \item END IF;
                        \end{description}

                        \item ELSE 
                        \begin{description}
                            \item IF NEW.Data < dati\_matricola.dataAssunzione OR NEW.Data > dati\_matricola.dataFine THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'La matricola \% non può essere dirigente (o essere rimosso da dirigente) fuori dal suo periodo di servizio!', NEW.Matricola;
                            \end{description}
                                \item END IF;
                        \end{description}
                        \item END IF;
                        
                        \vspace{0.5cm}
                        
                        \item OPEN cursore\_nuova\_matricola;
                        \item FETCH cursore\_nuova\_matricola INTO scatto\_precedente;
                        
                        \vspace{0.5cm}
                        
                        \item IF scatto\_precedente.Tipo <> 'Promosso a dirigente' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente \% non può avere come primo scatto "Rimosso da dirigente"!', NEW.Matricola;
                        \end{description}
                        \item END IF;

                        \item LOOP
                        \begin{description}
                            \item FETCH cursore\_nuova\_matricola INTO scatto\_attuale;
                            \item EXIT WHEN NOT FOUND;
                            
                            \vspace{0.5cm}
                            
                            \item IF scatto\_precedente.Tipo = scatto\_attuale.Tipo THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'Lo scatto in data \% è uguale a quello in data \% per la matricola \%', scatto\_precedente.Data, scatto\_attuale.Data, NEW.Matricola;
                            \end{description}

                            \item ELSIF catto\_precedente.Data = scatto\_attuale.Data THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'Il dipendente \% ha due scatti dirigenziali in data \%', NEW.Matricola, scatto\_precedente.Data;
                            \end{description}
                            \item END IF;
                            
                            \vspace{0.5cm}
                            
                            \item scatto\_precedente = scatto\_attuale;
                        \end{description}
                        \item END LOOP;
                        \item CLOSE cursore\_nuova\_matricola;
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER a\_tr\_verifica\_scatto\_dirigente\_IU
                    \item BEFORE INSERT OR UPDATE ON azienda.DIP\_INDETERMINATO
                    \item FOR EACH ROW
                    \item WHEN (NEW.Tipo = 'Rimosso da dirigente' OR NEW.Tipo = 'Promosso a dirigente')
                    \item EXECUTE FUNCTION azienda.fn\_verifica\_scatto\_dirigente\_IU();
                \end{description}
            \end{flushleft}
        \normalfont



        \subsubsection{verifica\_scatto\_dirigente\_D (DELETE)}
        Il trigger "verifica\_scatto\_dirigente\_D"  verifica la coerenza degli scatti di carriera relativi ai dirigenti di un'azienda. In particolare, il trigger viene attivato quando viene effettuata una cancellazione di uno scatto di carriera e la funzione controlla che gli scatti rimanenti per la vecchia matricola del dirigente siano coerenti tra di loro, ovvero che l'alternanza tra "Promosso a dirigente" e "Rimosso da dirigente" sia verificata e che il primo scatto non risulti essere "Rimosso da dirigente". Se viene rilevata una incongruenza, viene generata un'eccezione.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_verifica\_scatto\_dirigente\_D()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item cursore\_vecchia\_matricola CURSOR FOR 
                        \begin{description}
                            \item SELECT Tipo, Data
                            \item FROM azienda.scatto\_carriera
                            \item WHERE Matricola = OLD.Matricola AND (Tipo = 'Rimosso da dirigente' OR Tipo = 'Promosso a dirigente')
                            \item ORDER BY Data ASC;
                        \end{description}
                        \item scatto\_attuale RECORD;
                        \item scatto\_precedente RECORD;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item OPEN cursore\_vecchia\_matricola;
                        \item FETCH cursore\_vecchia\_matricola INTO scatto\_precedente;
                        \vspace{0.5cm}
                        \item IF FOUND THEN
                        \begin{description}
                            \item IF scatto\_precedente.Tipo <> 'Promosso a dirigente' THEN
                            \begin{description}
                                \item RAISE EXCEPTION 'Eliminando lo scatto di \%, il primo scatto risulta essere "Rimosso da dirigente"', OLD.Matricola;
                            \end{description}
                            END IF;

                            \item LOOP
                            \begin{description}
                                \item FETCH cursore\_vecchia\_matricola INTO scatto\_attuale;
                                \item EXIT WHEN NOT FOUND;
                                
                                \vspace{0.5cm}
                                
                                \item IF scatto\_precedente.Tipo = scatto\_attuale.Tipo THEN
                                \begin{description}
                                    \item RAISE EXCEPTION 'Lo scatto in data \% è uguale a quello in data \% per la matricola \%', scatto\_precedente.Data, scatto\_attuale.Data, OLD.Matricola;
                                \end{description}
                                \item END IF;

                                \vspace{0.5cm}
                                
                                \item scatto\_precedente = scatto\_attuale;
                            \end{description}
                            \item END LOOP;
                        \end{description}
                        \item END IF;
                        \item CLOSE cursore\_vecchia\_matricola;
                        
                        \item RETURN OLD;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER a\_tr\_verifica\_scatto\_dirigente\_D
                    \item AFTER DELETE ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item WHEN (OLD.Tipo = 'Rimosso da dirigente' OR OLD.Tipo = 'Promosso a dirigente')
                    \item EXECUTE FUNCTION azienda.fn\_verifica\_scatto\_dirigente\_D();
                \end{description}
            \end{flushleft}
        \normalfont


\newpage

        \subsubsection{aggiorna\_dirigente\_IU (INSERT \& UPDATE)}
        Il trigger "aggiorna\_dirigente\_IU" gestisce l'aggiornamento dello stato dirigenziale dei dipendenti dell'azienda. In particolare, la funzione verifica lo stato dirigenziale dei dipendenti coinvolti nella transazione e aggiorna la tabella "azienda.DIP\_INDETERMINATO" con lo stato dirigenziale aggiornato.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_aggiorna\_dirigente\_IU()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item tipo\_matricola azienda.scatto\_carriera.tipo\%TYPE;
                        \item dirigente\_matricola azienda.dip\_indeterminato.Dirigente\%TYPE;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item IF OLD.Matricola IS NOT NULL AND NEW.Matricola <> OLD.Matricola THEN
                        \begin{description}
                            \item SELECT Dirigente INTO dirigente\_matricola
                            \item FROM azienda.dip\_indeterminato
                            \item WHERE Matricola = OLD.Matricola;

                            \vspace{0.5cm}

                            \item SELECT Tipo INTO tipo\_matricola
                            \item FROM azienda.scatto\_carriera
                            \item WHERE Matricola = OLD.Matricola AND 
                                  \item (Tipo = 'Promosso a dirigente' OR Tipo = 'Rimosso da dirigente')
                            \item ORDER BY Data DESC
                            \item LIMIT 1;

                            \vspace{0.5cm}

                            \item IF NOT FOUND THEN
                            \begin{description}
                                \item UPDATE azienda.dip\_indetermianto
                                \item SET Dirigente = FALSE
                                \item WHERE Matricola = OLD.Matricola;
                            \end{description}

                            \item ELSE
                            \begin {description}
                                \item IF tipo\_matricola = 'Promosso a dirigente' THEN
                                \begin {description}
                                    \item IF dirigente\_matricola = FALSE THEN
                                    \begin{description}
                                        \item UPDATE azienda.dip\_indeterminato
                                        \item SET Dirigente = TRUE
                                        \item WHERE matricola = OLD.Matricola;
                                    \end{description}
                                    \item END IF;
                                \end{description}
                                \item ELSE
                                \begin{description}
                                    \item IF dirigente\_matricola = TRUE THEN
                                    \begin{description}
                                        \item UPDATE azienda.dip\_indeterminato
                                        \item SET Dirigente = FALSE
                                        \item WHERE matricola = OLD.Matricola;
                                    \end{description}
                                    \item END IF;
                                \end{description}
                                \item END IF;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;
                        
                        \vspace{0.5cm}

                        \item SELECT Tipo INTO tipo\_matricola 
                        \item FROM azienda.scatto\_carriera
                        \item WHERE Matricola = NEW.Matricola AND 
                        \item (Tipo = 'Promosso a dirigente' OR Tipo = 'Rimosso da dirigente')
                        \item ORDER BY Data DESC
                        \item LIMIT 1;

                        \vspace{0.5cm}

                        \item SELECT Dirigente INTO dirigente\_matricola 
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = NEW.Matricola;

                        \vspace{0.5cm}

                        \item IF tipo\_matricola = 'Promosso a dirigente' THEN
                        \begin{description}
                            \item IF dirigente\_matricola = FALSE THEN
                            \begin{description}
                                \item UPDATE azienda.dip\_indeterminato
                                \item SET Dirigente = TRUE
                                \item WHERE matricola = NEW.Matricola;
                            \end{description}
                            \item END IF;
                        \end {description}
                        \item ELSE
                        \begin{description}
                            \item IF dirigente\_matricola = TRUE THEN
                            \begin{description}
                                \item UPDATE azienda.dip\_indeterminato
                                \item SET Dirigente = FALSE
                                \item WHERE matricola = NEW.Matricola;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_aggiorna\_dirigente\_IU
                    \item AFTER INSERT OR UPDATE ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item WHEN (NEW.Tipo IN ('Promosso a dirigente', 'Rimosso da dirigente')) 
                    \item EXECUTE FUNCTION azienda.fn\_aggiorna\_dirigente\_IU();
                \end{description}
            \end{flushleft}
        \normalfont




        \subsubsection{aggiorna\_dirigente\_D (DELETE)}
        Il trigger "aggiorna\_dirigente\_D" controlla se un'eliminazione ha riguardato lo stato di dirigente di un dipendente e, in tal caso, aggiorna lo stato di dirigente nella tabella "azienda.DIP\_INDETERMINATO"
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_aggiorna\_dirigente\_D()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item tipo\_matricola azienda.scatto\_carriera.tipo\%TYPE;
                        \item dirigente\_matricola azienda.dip\_indeterminato.Dirigente\%TYPE;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT Dirigente INTO dirigente\_matricola 
                        \item FROM azienda.dip\_indeterminato
                        \item WHERE Matricola = OLD.Matricola;
                            
                        \vspace{0.5cm}

                        \item SELECT Tipo INTO tipo\_matricola 
                        \item FROM azienda.scatto\_carriera
                        \item WHERE Matricola = OLD.Matricola AND 
                        \item (Tipo = 'Promosso a dirigente' OR Tipo = 'Rimosso da dirigente')
                        \item ORDER BY Data DESC
                        \item LIMIT 1;

                        \vspace{0.5cm}

                        \item IF NOT FOUND THEN 
                            \begin{description}
                                \item UPDATE azienda.dip\_indeterminato
                                \item SET Dirigente = FALSE
                                \item WHERE Matricola = OLD.Matricola;
                            \end{description}
                        \item ELSE
                        \begin{description}
                            \item IF tipo\_matricola = 'Promosso a dirigente' THEN
                            \begin{description}
                                \item IF dirigente\_matricola = FALSE THEN
                                \begin{description}
                                    \item UPDATE azienda.dip\_indeterminato
                                    \item SET Dirigente = TRUE
                                    \item WHERE matricola = OLD.Matricola;
                                \end{description}
                                \item END IF;
                            \end{description}
                            \item ELSE 
                            \begin{description}
                                \item IF dirigente\_matricola = TRUE THEN
                                \begin{description}
                                    \item UPDATE azienda.dip\_indeterminato
                                    \item SET Dirigente = FALSE
                                    \item WHERE matricola = OLD.Matricola;
                                \end{description}
                                \item END IF;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;
                        \item RETURN OLD;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER b\_tr\_aggiorna\_dirigente\_D
                    \item AFTER DELETE ON azienda.SCATTO\_CARRIERA
                    \item FOR EACH ROW
                    \item WHEN (OLD.Tipo IN ('Promosso a dirigente', 'Rimosso da dirigente')) 
                    \item EXECUTE FUNCTION azienda.fn\_aggiorna\_dirigente\_D();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsection{TRIGGERS PER azienda.LABORATORIO}

        \subsubsection{res\_scientifico\_senior}
        Il trigger "res\_scientifico\_senior" ha il compito di verificare se il dipendente che viene assegnato come Responsabile Scientifico per un laboratorio è di tipo "Senior" e se è attualmente in servizio. In caso contrario, viene generata un'eccezione. Si noti che viene anche verificato che la matricola inserita effettivamente esista. Questo ha il solo scopo di generare un messaggio di errore personalizzato, dato che tale vincolo è verificato già dal vincolo di chiave esterna.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_res\_scientifico\_senior()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item DECLARE
                    \begin{description}
                        \item dip\_ind RECORD;
                    \end{description}
                    \item BEGIN 
                    \begin{description}
                        \item SELECT Nome, Cognome, Matricola, Tipo, DataFine INTO dip\_ind
                        \item FROM azienda.DIP\_INDETERMINATO
                        \item WHERE Matricola = NEW.Responsabile\_Scientifico;
                        
                        \item IF dip\_ind.Matricola IS NULL THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'La matricola \% non esiste', NEW.Responsabile\_Scientifico;
                        \end{description}
                        \item END IF;
                    
                        \vspace{0.5cm}

                        \item IF dip\_ind.Tipo <> 'Senior' THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% non è di tipo "Senior"! Non può essere nominato Responsabile scientifico per il laboratorio \%', dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola, NEW.Nome;
                        \end{description}
                        \item END IF;
                        
                        \vspace{0.5cm}
                        
                        \item IF dip\_ind.DataFine IS NOT NULL THEN
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% ha una data di licenziamento! Non è possibile assegnare l''incarico di Responsabile Scientifico del laboratorio \%!', dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola, NEW.Nome;
                        \end{description}
                        \item END IF;
                        
                        \vspace{0.5cm}
                    
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_res\_scientifico\_senior
                    \item BEFORE INSERT OR UPDATE OF Responsabile\_Scientifico 
                    \item ON azienda.LABORATORIO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_res\_scientifico\_senior();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage
    
        \subsubsection{aggiungi\_lab\_res\_scient\_I (INSERT)}
        Il trigger "aggiungi\_lab\_res\_scient\_I" aggiunge automaticamente l'afferenza del responsabile scientifico di un nuovo laboratorio.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_aggiungi\_lab\_res\_scient\_I()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item INSERT INTO azienda.AFFERIRE(Matricola, nomeLab)
                        \item VALUES (NEW.Responsabile\_scientifico, NEW.nome);
                                                            
                        \vspace{0.5cm}

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_z\_aggiungi\_lab\_res\_scient\_I
                    \item AFTER INSERT ON azienda.LABORATORIO
                    \item FOR EACH ROW
                    \item EXECUTE FUNCTION azienda.fn\_aggiungi\_lab\_res\_scient\_I();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{aggiungi\_lab\_res\_scient\_non\_afferente\_U (UPDATE)}
        Il trigger "aggiungi\_lab\_res\_scient\_non\_afferente\_U" verifica se il nuovo Responsabile Scientifico del laboratorio non è già afferente al laboratorio stesso. Se non lo è, la funzione sostituisce l'attuale Responsabile Scientifico del laboratorio con il nuovo Responsabile Scientifico nella tabella "azienda.AFFERIRE".
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_aggiungi\_lab\_res\_scient\_non\_afferente\_U()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item IF NOT EXISTS (SELECT *
                        \item FROM azienda.AFFERIRE
                        \item WHERE Matricola = NEW.Responsabile\_scientifico AND
                        \item nomeLab = OLD.nome) THEN
                        \begin{description}
                            \item UPDATE azienda.AFFERIRE
                            \item SET Matricola = NEW.Responsabile\_Scientifico
                            \item WHERE Matricola = OLD.Responsabile\_Scientifico AND nomeLab = OLD.nome;

                            \vspace{0.5cm}

                            \item RAISE NOTICE 'L''afferenza del vecchio responsabile scientifico \% è stata sostituita con l''afferenza del nuovo responsabile scientifico \% per il laboratorio \%
                            \item Non è stata conservata l''afferenza del vecchio responsabile scientifico \%, che ora non afferirà più al laboratorio \%', OLD.Responsabile\_Scientifico, NEW.Responsabile\_Scientifico, NEW.nome, OLD.Responsabile\_Scientifico, NEW.nome;
                        \end{description}
                        \item END IF;

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_z\_aggiungi\_lab\_res\_scient\_non\_afferente\_U
                    \item BEFORE UPDATE OF Responsabile\_Scientifico
                    \item ON azienda.LABORATORIO
                    \item FOR EACH ROW
                    \item WHEN (OLD.nome <> NEW.nome OR OLD.Responsabile\_scientifico <> NEW.Responsabile\_scientifico)
                    \item EXECUTE FUNCTION azienda.fn\_aggiungi\_lab\_res\_scient\_non\_afferente\_U();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{aggiungi\_lab\_res\_scient\_afferente\_U (UPDATE)}
        Il trigger "aggiungi\_lab\_res\_scient\_afferente\_U" ha l'obiettivo di mantenere aggiornate le afferenze al laboratorio in seguito alla modifica del Responsabile Scientifico con un dipendente già afferente al laboratorio. In tal caso, infatti, è necessario solo eliminare l'afferenza del vecchio Responsabile Scientifico.
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER azienda.fn\_aggiungi\_lab\_res\_scient\_afferente\_U()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item IF NOT EXISTS (SELECT *
                        \item FROM azienda.AFFERIRE
                        \item WHERE Matricola = OLD.Responsabile\_scientifico AND
                        \item nomeLab = OLD.nome) THEN
                        \begin{description}
                            \item DELETE FROM azienda.AFFERIRE
                            \item WHERE Matricola = OLD.Responsabile\_Scientifico AND nomeLab = OLD.nome;

                            \vspace{0.5cm}

                            \item RAISE NOTICE 'L''afferenza del vecchio responsabile scientifico \% è stata sostituita con l''afferenza del nuovo responsabile scientifico \% per il laboratorio \%
                            \item Non è stata conservata l''afferenza del vecchio responsabile scientifico \%, che ora non afferirà più al laboratorio \%', OLD.Responsabile\_Scientifico, NEW.Responsabile\_Scientifico, NEW.nome, OLD.Responsabile\_Scientifico, NEW.nome;
                        \end{description}
                        \item END IF;

                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_z\_aggiungi\_lab\_res\_scient\_afferente\_U
                    \item AFTER UPDATE OF Responsabile\_Scientifico
                    \item ON azienda.LABORATORIO
                    \item FOR EACH ROW
                    \item WHEN (OLD.nome <> NEW.nome OR OLD.Responsabile\_scientifico <> NEW.Responsabile\_scientifico)
                    \item EXECUTE FUNCTION azienda.fn\_aggiungi\_lab\_res\_scient\_afferente\_U();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

        \subsubsection{blocco\_nAfferenti}
        Il trigger "blocco\_nAfferenti" blocca le modifiche dirette al campo "nAfferenti" della tabella "azienda.LABORATORIO".
        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE FUNCTION azienda.fn\_blocco\_nAfferenti()  
                    \item RETURNS trigger
                    \item AS
                    \item \$\$
                    \item BEGIN 
                    \begin{description}
                        \item IF OLD.nome IS NULL THEN
                        \begin{description}
                            \item IF NEW.nAfferenti <> 1 THEN
                            \begin{description}
                                \item RAISE NOTICE 'Non è possibile inserire direttamente il numero di afferenti al laboratorio %!', NEW.nome;
                                \item NEW.nAfferenti = 1;
                            \end{description}
                            \item END IF;
                        \end{description}
                        
                        \vspace{0.5cm}

                        \item ELSE 
                        \begin{description}
                            \item IF NEW.nAfferenti <> OLD.nAfferenti THEN
                            \begin{description}
                                \item RAISE NOTICE 'Non è possibile modificare direttamente il numero di afferenti al laboratorio %!', NEW.nome;
                                \item NEW.nAfferenti = OLD.nAfferenti;
                            \end{description}
                            \item END IF;
                        \end{description}
                        \item END IF;
                
                        \item RETURN NEW;
                    \end{description}
                    \item END;
                    \item \$\$
                    \item LANGUAGE plpgsql;
                \end{description}
            \end{flushleft}
        \normalfont

        \ttfamily
            \begin{flushleft}
                \begin{description}
                    \item CREATE OR REPLACE TRIGGER tr\_blocco\_nAfferenti
                    \item BEFORE INSERT OR UPDATE OF nAfferenti
                    \item ON azienda.LABORATORIO
                    \item FOR EACH ROW
                    \item WHEN (pg\_trigger\_depth() < 1)
                    \item EXECUTE FUNCTION azienda.fn\_blocco\_nAfferenti();
                \end{description}
            \end{flushleft}
        \normalfont

\newpage

    \subsection{TRIGGERS PER azienda.AFFERIRE}

    \subsubsection{verifica\_afferenza}
    Il trigger "verifica\_afferenza" verifica che la matricola inserita esista e sia assegnata ad un dipendente a tempo indeterminato senza data di licenziamento e che il laboratorio esista.\\
    Da notare che i controlli riguardanti l'esistenza della matricola e del laboratorio sono effettuati solo ed esclusivamente per personalizzare il messaggio di errore.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_verifica\_afferenza()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item BEGIN
                \begin{description}
                    \item IF NOT EXISTS (SELECT *
                    \item \hspace{2.6cm} FROM azienda.DIP\_INDETERMINATO
                    \item \hspace{2.6cm} WHERE Matricola = NEW.Matricola) THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'La matricola \% non esiste!', NEW.Matricola;
                    \end{description}
                    \item END IF;
                \end{description}
    
                \vspace{0.5cm}
            
                \begin{description}
                    \item IF NOT EXISTS (SELECT *
                    \item \hspace{2.6cm} FROM azienda.LABORATORIO
                    \item \hspace{2.6cm} WHERE nome = NEW.nomeLab) THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'Il laboratorio \% non esiste!', NEW.nomeLab;
                    \end{description}
                    \item END IF;
                \end{description}

                \vspace{0.5cm}

                \begin{description}
                    \item IF (SELECT dataFine
                    \item \hspace{0.55cm} FROM azienda.DIP\_INDETERMINATO
                    \item \hspace{0.55cm} WHERE Matricola = NEW.Matricola) IS NOT NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'La matricola \% ha una data di licenziamento! Non è possibile assegnare la nuova afferenza al laboratorio \%.', NEW.Matricola, NEW.nomeLab;
                    \end{description}
                    \item END IF;
                \end{description}

                \vspace{0.5cm}

                \begin{description}
                    \item RETURN NEW;
                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_verifica\_afferenza
                \item BEFORE INSERT ON azienda.AFFERIRE
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_verifica\_afferenza();
            \end{description}
        \end{flushleft}
    \normalfont

    \newpage

    \subsubsection{blocco\_aff\_lab\_res\_scient}
    Il trigger "blocco\_aff\_lab\_res\_scient" garantisce che non venga eliminata o aggiornata accidentalmente l'afferenza di un responsabile scientifico di un laboratorio quando si sta operando sulla relazione "azienda.AFFERIRE".\\
    In particolare, il trigger verificherà che non si stia tentando di rimuovere o modificare l'afferenza di un responsabile scientifico di un laboratorio senza prima aver eliminato il laboratorio corrispondente o aver sostituito la matricola del responsabile scientifico per il laboratorio in questione.\\
    La condizione "\textit{WHEN pg\_trigger\_depth() \(<\) 1}" serve ad assicurare che il trigger venga attivato solo quando si sta eliminando o aggiornando una tupla direttamente dalla relazione azienda.AFFERIRE. Questo previene l'attivazione del trigger durante l'esecuzione di altri trigger e garantisce che il controllo sulla matricola venga effettuato correttamente.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_blocco\_aff\_lab\_res\_scient()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item BEGIN
                \begin{description}
                    \item IF EXISTS (SELECT *
                    \item \hspace{1.9cm} FROM azienda.LABORATORIO
                    \item \hspace{1.9cm} WHERE Responsabile\_scientifico = OLD.Matricola AND
                    \item \hspace{3cm}   nome = OLD.nomeLab) THEN
                    \vspace{0.2cm}
                    \begin{description} 
                        \item RAISE EXCEPTION 'Non è possibile eliminare l''afferenza del responsabile 
                        \item \hspace{2.8cm} scientifico \% del laboratorio \%!',
                        \item \hspace{2.8cm} OLD.Matricola, OLD.nomeLab;
                    \end{description}
                    \item END IF;
                \end{description}

                \vspace{0.5cm}

                \begin{description}
                    \item RETURN OLD;
                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_blocco\_aff\_lab\_res\_scient
                \item BEFORE DELETE OR UPDATE OF Matricola, nomeLab
                \item ON azienda.AFFERIRE
                \item FOR EACH ROW
                \item WHEN (pg\_trigger\_depth() < 1)
                \item EXECUTE FUNCTION azienda.fn\_blocco\_aff\_lab\_res\_scient();
            \end{description}
        \end{flushleft}
    \normalfont

    \subsubsection{change\_nAfferenti\_I (INSERT)}
    Il trigger "change\_nAfferenti\_I" verifica che, dopo la registrazione dell'afferenza di un dipendente a tempo indeterminato ad un laboratorio, 
    la matricola del dipendente appena inserita non sia quella del responsabile scientifico di quel laboratorio, al fine di aggiornare correttamente il numero di afferenti ad un laboratorio.\\
    Se così fosse, non deve essere incrementato il numero di afferenti del laboratorio, poichè l'afferenza del responsabile scientifico è già conteggiata; altrimenti incrementa il numero di afferenti.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_change\_nAfferenti\_I()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item BEGIN
                \begin{description}
                    \item IF NEW.Matricola = (SELECT Responsabile\_scientifico
                    \item \hspace{3.5cm} FROM azienda.LABORATORIO
                    \item \hspace{3.5cm} WHERE nome = NEW.nomeLab) THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE NOTICE 'L''afferenza del Responsabile Scientifico \% di \%
                        \item \hspace{2.3cm} è già conteggiata!', NEW.Matricola, NEW.nomeLab;
                    \end{description}
                    \item ELSE
                    \vspace{0.2cm}
                    \begin{description} 
                        \item UPDATE azienda.LABORATORIO
                        \item SET nAfferenti = nAfferenti + 1
                        \item WHERE nome = NEW.nomeLab;
                        \vspace{0.5cm}
                        \item RAISE NOTICE 'Incrementato di 1 il numero di afferenti
                        \item \hspace{2.3cm} del laboratorio \%!', NEW.nomeLab;
                    \end{description}
                    \item END IF;
                \end{description}

                \vspace{0.2cm}

                \begin{description}
                    \item RETURN NEW;
                \end{description}
            \item END;
            \item \$\$
            \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_change\_nAfferenti\_I
                \item AFTER INSERT
                \item ON azienda.AFFERIRE
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_change\_nAfferenti\_I();
            \end{description}
        \end{flushleft}
    \normalfont

    \subsubsection{change\_nAfferenti\_U (UPDATE)}
    Il trigger "change\_nAfferenti\_U" verifica che ci sia coerenza, in una tupla di "azienda.LABORATORIO", tra l'attributo "nAfferenti" e il numero di afferenze al laboratorio stesso, dopo eventuali aggiornamenti.\\
    In particolare, data una tupla "(Matricola, nomeLab)" in "azienda.AFFERIRE", vengono analizzate le seguenti circostanze:
    \begin{enumerate}
        \item Nel caso venga aggiornata solo la matricola, il laboratorio non perde alcuna afferenza siccome è rimasto lo stesso, pertanto nAfferenti rimane invariato
        \item Nel caso venga aggiornato solo il laboratorio, il vecchio laboratorio perde una afferenza, mentre il nuovo la guadagna
        \item Nel caso vengano aggiornati entrambi, il vecchio laboratorio perderà una afferenza, mentre il nuovo laboratorio ne guadagna una.
    \end{enumerate}

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_change\_nAfferenti\_U()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item BEGIN
                \begin{description}
                    \item IF EXISTS (SELECT *
                    \item \hspace{1.85cm} FROM azienda.LABORATORIO
                    \item \hspace{1.85cm} WHERE nome = OLD.nomeLab) THEN
                    \vspace{0.455cm}
                    \begin{description}
                        \item UPDATE azienda.LABORATORIO
                        \item SET nAfferenti = nAfferenti - 1
                        \item WHERE nome = OLD.nomeLab;
                        \item
                        \item RAISE NOTICE 'Decrementato di 1 il numero di afferenti del vecchio
                        \item \hspace{2.3cm} laboratorio \%!', OLD.nomeLab;
                        \item 
                        \item UPDATE azienda.LABORATORIO
                        \item SET nAfferenti = nAfferenti + 1
                        \item WHERE nome = NEW.nomeLab;
                        \item 
                        \item RAISE NOTICE 'Incrementato di 1 il numero di afferenti del nuovo 
                        \item \hspace{2.3cm} laboratorio \%!', NEW.nomeLab;
                    \end{description}
                    \item END IF;
                    \item 
                    \item RETURN NEW;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_change\_nAfferenti\_U
                \item AFTER UPDATE
                \item ON azienda.AFFERIRE
                \item FOR EACH ROW
                \item WHEN (NEW.nomeLab <> OLD.nomeLab)
                \item EXECUTE FUNCTION azienda.fn\_change\_nAfferenti\_U();
            \end{description}
        \end{flushleft}
    \normalfont

    \newpage

    \subsubsection{change\_nAfferenti\_D (DELETE)}
    Il trigger "change\_nAfferenti\_D" verifica che, per ogni rimozione di una afferenza per un determinato laboratorio, si decrementi il numero di afferenti
    del laboratorio in questione.

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_change\_nAfferenti\_D()
                \item RETURNS TRIGGER
                \item AS 
                \item \$\$
                \item BEGIN
                \begin{description}
                    \item UPDATE azienda.LABORATORIO
                    \item SET nAfferenti = nAfferenti - 1
                    \item WHERE nome = OLD.nomeLab;
                    \item 
                    \item RAISE NOTICE 'Decrementato di 1 il numero di afferenti del laboratorio \%!', OLD.nomeLab;
                    \item 
                    \item RETURN OLD;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_change\_nAfferenti\_D
                \item AFTER DELETE
                \item ON azienda.AFFERIRE
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_change\_nAfferenti\_D();
            \end{description}
        \end{flushleft}
    \normalfont

\newpage

    \subsection{TRIGGERS PER azienda.PROGETTO}

    \subsubsection{ref\_scientifico\_senior}
    Il trigger "ref\_scientifico\_senior" verifica che, quando si inserisce un progetto oppure si aggiorna l'attributo "Referente\_scientifico"
    per un progetto già esistente, il nuovo referente scientifico sia di tipo "Senior".
    Si noti il controllo sulla matricola del nuovo referente scientifico, fatto solo per personalizzare il messaggio di errore.

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_ref\_scientifico\_senior()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dip\_ind RECORD;
                \end{description}
                \item BEGIN
                \begin{description}
                    \item SELECT Nome, Cognome, Matricola, Tipo, DataFine	INTO dip\_ind
                    \item FROM azienda.DIP\_INDETERMINATO
                    \item WHERE Matricola = NEW.Referente\_Scientifico;
                    \item 
                    \item IF dip\_ind.Matricola IS NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'La matricola \% non esiste', NEW.Referente\_Scientifico;
                    \end{description}
                    \item END IF;
                    \item 
                    \item IF dip\_ind.Tipo <> 'Senior' THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% non è di tipo
                        \item \hspace{3cm}"Senior"! Non è stato possibile assegnarlo come
                        \item \hspace{3cm}referente scientifico del progetto \%',
                        \item \hspace{3cm}dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola, NEW.CUP;
                    \end{description}
                    \item END IF;
                    \item
                    \item IF NEW.dataFine IS NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item IF dip\_ind.DataFine IS NOT NULL THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% ha una data
                            \item \hspace{3cm}di licenziamento! Non è possibile assegnare
                            \item \hspace{3cm}l''incarico di Referente Scientifico del progetto \%'
                            \item \hspace{3cm}dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola,
                            \item \hspace{3cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item ELSE
                    
                    \newpage

                    \begin{description}
                        \item IF dip\_ind.DataFine IS NOT NULL AND dip\_ind.DataFine < NEW.dataFine THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% è stato licenziato
                            \item \hspace{3cm}prima della fine del progetto! Non è stato possibile
                            \item \hspace{3cm}assegnarlo come referente scientifico del progetto \%',
                            \item \hspace{3cm}dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola,
                            \item \hspace{3cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item END IF;
                    \item 
                    \item RETURN NEW;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_ref\_scientifico\_senior
                \item BEFORE INSERT OR UPDATE OF Referente\_Scientifico
                \item ON azienda.PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_ref\_scientifico\_senior();
            \end{description}
        \end{flushleft}
    \normalfont

    \newpage

    \subsubsection{res\_progetto\_dirigente}
    Il trigger "res\_progetto\_dirigente" verifica che, quando si inserisce un progetto oppure si aggiorna l'attributo "Responsabile"
    per un progetto già esistente, il nuovo responsabile sia un dirigente.
    Si noti il controllo sulla matricola del nuovo responsabile, fatto solo per personalizzare il messaggio di errore.
    
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_res\_progetto\_dirigente()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dip\_ind RECORD;
                \end{description}
                \item BEGIN
                \begin{description}
                    \item SELECT Nome, Cognome, Matricola, Dirigente, DataFine	INTO dip\_ind
                    \item FROM azienda.DIP\_INDETERMINATO
                    \item WHERE Matricola = NEW.Responsabile;
                    \item 
                    \item IF dip\_ind.Matricola IS NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'La matricola \% non esiste', NEW.Responsabile;
                    \end{description}
                    \item END IF;
                    \item 
                    \item IF dip\_ind.Dirigente <> TRUE THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% non è "Dirigente"!
                        \item \hspace{3cm}Non è stato possibile assegnarlo come responsabile
                        \item \hspace{3cm} del progetto \%', dip\_ind.Nome, dip\_ind.Cognome,
                        \item \hspace{3cm}dip\_ind.Matricola, NEW.CUP;
                    \end{description}
                    \item END IF;
                    \item
                    \item IF NEW.dataFine IS NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item IF dip\_ind.DataFine IS NOT NULL THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% ha una data
                            \item \hspace{3cm}di licenziamento! Non è possibile assegnare
                            \item \hspace{3cm}l''incarico di Responsabile al progetto \%'
                            \item \hspace{3cm}dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola,
                            \item \hspace{3cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item ELSE
                    
                    \newpage

                    \begin{description}
                        \item IF dip\_ind.DataFine IS NOT NULL AND dip\_ind.DataFine < NEW.dataFine THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE EXCEPTION 'Il dipendente "\% \%" con matricola \% è stato licenziato
                            \item \hspace{3cm}prima della fine del progetto! Non è stato possibile
                            \item \hspace{3cm}assegnarlo come responsabile del progetto \%',
                            \item \hspace{3cm}dip\_ind.Nome, dip\_ind.Cognome, dip\_ind.Matricola,
                            \item \hspace{3cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item END IF;
                    \item 
                    \item RETURN NEW;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_res\_progetto\_dirigente
                \item BEFORE INSERT OR UPDATE OF Responsabile
                \item ON azienda.PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_res\_progetto\_dirigente();
            \end{description}
        \end{flushleft}
    \normalfont

    \newpage

    \subsubsection{blocco\_modifiche\_budget\_costi}
    Il trigger "blocco\_modifiche\_budget\_costi" verifica che venga impedita qualsiasi modifica diretta agli attributi
    "costoAttrezzature" e "costoContrattiProgetto" per una tupla della relazione "azienda.PROGETTO"
    La condizione "\textit{WHEN pg\_trigger\_depth() \textless 1}" serve per innescare il trigger ogni qual volta si intende inserire o aggiornare una tupla direttamente dalla relazione azienda.PROGETTO,
    evitando così che il bloccco sull'inserimento o l'aggiornamento si presenti durante l'azione di trigger innescati prima di esso.

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_blocco\_modifiche\_budget\_costi()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item half\_budget azienda.EURO := (0.5 * NEW.Budget)-0.005;
                \end{description}
                \item BEGIN
                \begin{description}
                    \item IF OLD.CostoAttrezzature IS NULL THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item IF (NEW.costoAttrezzature <> 0 OR NEW.costoContrattiProgetto <> 0) THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE NOTICE E'Non puoi inserire manualmente il costo totale delle
                            \item \hspace{2.6cm}attrezzature o il costo totale dei contratti
                            \item \hspace{2.6cm}a progetto di \%!$\backslash$nBisogna comprare le attrezzature
                            \item \hspace{2.6cm}o i contratti relativi a questo progetto.$\backslash$n
                            \item \hspace{2.6cm}L''inserimento a questi campi è stato ignorato',
                            \item \hspace{2.6cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item ELSE
                    \begin{description}
                        \item IF (NEW.CostoAttrezzature <> OLD.costoAttrezzature OR
                        \item \hspace{0.75cm}NEW.costoContrattiProgetto <> OLD.costoContrattiProgetto) THEN
                        \vspace{0.2cm}
                        \begin{description}
                            \item RAISE NOTICE E'Non puoi modificare manualmente il costo totale delle
                            \item \hspace{2.6cm}attrezzature o il costo totale dei contratti
                            \item \hspace{2.6cm}a progetto di \%!$\backslash$nBisogna modificare gli acquisti
                            \item \hspace{2.6cm}delle attrezzature o i contratti 
                            \item \hspace{2.6cm}relativi a questo progetto.$\backslash$n
                            \item \hspace{2.6cm}Le modifiche di questi campi sono state ignorate',
                            \item \hspace{2.6cm}NEW.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item END IF;
                    \item
                    \item RETURN NEW;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_blocco\_modifiche\_budget\_costi
                \item BEFORE INSERT OR UPDATE OF costoAttrezzature, costoContrattiProgetto ON azienda.PROGETTO
                \item FOR EACH ROW
                \item WHEN (pg\_trigger\_depth() < 1)
                \item EXECUTE FUNCTION azienda.fn\_blocco\_modifiche\_budget\_costi();
            \end{description}
        \end{flushleft}
    \normalfont

\newpage

    \subsubsection{verifica\_budget\_costi}
    Il trigger "verifica\_budget\_costi" blocca la modifica del "Budget" nel caso l'attuale "costoAttrezzature" o "costoContrattiProgetto" sforino il limite del 50\% del nuovo "Budget".

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_verifica\_budget\_costi()
                \item RETURNS TRIGGER
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item half\_budget azienda.EURO := (0.5 * NEW.Budget)-0.005;
                \end{description}
                \item BEGIN
                \begin{description}
                    \item IF ((half\_budget < NEW.CostoAttrezzature) OR
                    \item \hspace{0.75cm}(half\_budget < NEW.costoContrattiProgetto)) THEN
                    \vspace{0.2cm}
                    \begin{description}
                        \item RAISE EXCEPTION 'Non è stato possibile modificare il Budget da \% a \%
                        \item \hspace{3cm}perchè attualmente per il progetto \% vi è una spesa
                        \item \hspace{3cm}in attrezzature o contratti a progetto superiore
                        \item \hspace{3cm}a \% (il 50\%\% di \%)! Modifica rifiutata.',
                        \item \hspace{3cm}OLD.Budget, NEW.Budget, NEW.CUP, half\_budget, NEW.Budget;
                    \end{description}
                    \item END IF;
                    \item
                    \item RETURN NEW;
                \end{description}
                \item END;
                \item \$\$
                \item LANGUAGE PLPGSQL;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_verifica\_budget\_costi
                \item BEFORE UPDATE OF Budget ON azienda.PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_verifica\_budget\_costi();
            \end{description}
        \end{flushleft}
    \normalfont

\newpage

    \subsection{TRIGGERS PER azienda.LAVORARE}

    \subsubsection{controllo\_laboratori\_progetto}
    Il trigger "controllo\_laboratori\_progetto" controlla la correttezza e la coerenza dei dati inseriti nella tabella "azienda.LAVORARE". In particolare, controlla che il numero massimo di laboratori assegnati ad un progetto (cioè massimo 3 laboratori) non sia superato. Vengono effettuati ulteriori controlli sull'esistenza del progetto o del laboratorio con il solo scopo di personalizzare il messaggio di errore rispetto a quello che già darebbe per violazione di vincolo di chiave esterna o di chiave primaria.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_controllo\_laboratori\_progetto()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item lavora\_su RECORD;
                    \item cup\_exists RECORD;
                    \item laboratorio\_exists RECORD;
                    \item numLabOnProg INTEGER := 0;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT * INTO cup\_exists
                    \item FROM azienda.PROGETTO 
                    \item WHERE CUP = NEW.CUP;
                
                    \vspace{0.5cm}

                    \item IF NOT FOUND THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Il progetto con CUP \% non esiste', NEW.CUP;
                    \end{description}
                    \item END IF;
                
                    \vspace{0.5cm}

                    \item SELECT * INTO laboratorio\_exists
                    \item FROM azienda.LABORATORIO
                    \item WHERE nome = NEW.nomeLab;
                
                    \vspace{0.5cm}

                    \item IF NOT FOUND THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Il laboratorio \% non esiste', NEW.nomeLab;
                    \end{description}
                    \item END IF;
                    
                    \vspace{0.5cm}
                
                    \item SELECT * INTO lavora\_su
                    \item FROM azienda.LAVORARE
                    \item WHERE CUP = NEW.CUP AND nomeLab = NEW.nomeLab;
                
                    \vspace{0.5cm}

                    \item IF FOUND THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Il laboratorio \% lavora già sul progetto con CUP \%', NEW.nomeLab, NEW.CUP;
                    \end{description}
                    \item END IF;

                    \vspace{0.5cm}

                    \item SELECT COUNT(*) INTO numLabOnProg
                    \item FROM azienda.LAVORARE
                    \item WHERE CUP = NEW.CUP AND
                    \item nomeLab NOT IN(
                    \begin{description}
                        \item SELECT nomeLab
                        \item FROM azienda.LAVORARE
                        \item WHERE CUP = OLD.CUP AND nomeLab = OLD.nomeLab
                    \end{description}
                    \item )

                    \item IF numLabOnProg >= 3 THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Non è possibile assegnare più di 3 laboratori ad un progetto! Il laboratorio \% non può essere aggiunto al progetto \%', NEW.nomeLab, NEW.CUP;
                    \end{description}
                    \item END IF;

                    \item RETURN NEW;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_controllo\_laboratori\_progetto
                \item BEFORE INSERT OR UPDATE ON azienda.LAVORARE
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_controllo\_laboratori\_progetto();
            \end{description}
        \end{flushleft}
    \normalfont

\newpage

    \subsection{TRIGGERS PER azienda.ATTREZZATURA}

    \subsubsection{coerenza\_acquisto\_attr\_lab}
    Il trigger "coerenza\_acquisto\_attr\_lab" verifica che il laboratorio a cui si vuole assegnare un'attrezzatura lavori effettivamente per il progetto tramite cui l'attrezzatura è stata acquistata. Viene inoltre verificato che il laboratorio e il progetto specificati esistano effettivamente. Ciò ha solo finalità di messaggio di errore personalizzato.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_coerenza\_acquisto\_attr\_lab()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item corrispondenze RECORD;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item IF NOT EXISTS (SELECT *
                    \item FROM azienda.LABORATORIO
                    \item WHERE nome = NEW.nomeLab) THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Il laboratorio \% non esiste!', NEW.nomeLab;
                    \end{description}
                    \item END IF;
                    
                    \vspace{0.5cm}
                
                    \item IF NOT EXISTS (SELECT *
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = NEW.CUP) THEN
                    \begin{description}
                        \item RAISE EXCEPTION 'Il progetto \% non esiste!', NEW.CUP;
                    \end{description}
                    \item END IF;
                
                    \vspace{0.5cm}

                    \item IF NOT EXISTS (SELECT *
                    \item FROM azienda.LAVORARE
                    \item WHERE CUP = NEW.CUP AND nomeLab = NEW.nomeLab) THEN
                    \begin {description}
                        \item RAISE EXCEPTION 'Il laboratorio \% non lavora per il progetto \%, \% non registrato come attrezzatura!', NEW.nomeLab, NEW.CUP, NEW.Descrizione;
                    \end{description}
                    \item END IF;
                
                    \item RETURN NEW;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_coerenza\_acquisto\_attr\_lab
                \item BEFORE INSERT OR UPDATE OF nomeLab, CUP
                \item ON azienda.ATTREZZATURA
                \item FOR EACH ROW
                \item WHEN (NEW.nomeLab IS NOT NULL AND NEW.CUP IS NOT NULL) 
                \item EXECUTE FUNCTION azienda.fn\_coerenza\_acquisto\_attr\_lab();
            \end{description}
        \end{flushleft}
    \normalfont


    \subsubsection{incr\_costo\_attrezzature\_e\_50\_I (INSERT)}
    Il trigger "incr\_costo\_attrezzature\_e\_50\_I" controlla l'aggiunta di una nuova attrezzatura ad un progetto dell'azienda, verificando che il costo totale delle attrezzature non superi il 50\% del budget del progetto, se la condizione è verificata il trigger aggiorna il costo totale delle attrezzature del progetto con il nuovo valore. In caso contrario l'attrezzatura non viene inserita.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_I()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                    \item half\_budget azienda.EURO := 0;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoAttrezzature INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = NEW.CUP;
                    
                    \vspace{0.5cm}

                    \item dati\_progetto.CostoAttrezzature = dati\_progetto.CostoAttrezzature + NEW.Costo;
                
                    \item half\_budget := (0.5 \* dati\_progetto.Budget)-0.005;
                
                    \vspace{0.5cm}

                    \item IF half\_budget >= dati\_progetto.CostoAttrezzature THEN
                    \begin{description}
                        \item UPDATE azienda.PROGETTO AS PR
                        \item SET costoAttrezzature = dati\_progetto.CostoAttrezzature
                        \item WHERE PR.CUP = NEW.CUP;
                    \end{description}
                    \item ELSE
                    \begin{description}
                        \item RAISE EXCEPTION 'Il costo totale delle attrezzature, ovvero €\%, sfora il 50\%\% del budget (€\%)! L''attrezzatura "\%" non è stata acquistata per il progetto \%', dati\_progetto.CostoAttrezzature, half\_budget, NEW.Descrizione, NEW.CUP;
                    \end{description}
                    \item END IF;
                
                    \item RETURN NEW;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_attrezzature\_e\_50\_I
                \item BEFORE INSERT ON azienda.ATTREZZATURA
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_I();
            \end{description}
        \end{flushleft}
    \normalfont

    
    \subsubsection{incr\_costo\_attrezzature\_e\_50\_U (UPDATE)}
    Il trigger "incr\_costo\_attrezzature\_e\_50\_U" verifica se la modifica del costo di un'attrezzatura in un progetto supera il 50\% del budget del progetto stesso. In caso contrario, viene aggiornato il costo delle attrezzature nel progetto.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_U()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                    \item half\_budget azienda.EURO := 0;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoAttrezzature INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = NEW.CUP;
                    
                    \vspace{0.5cm}

                    \item dati\_progetto.CostoAttrezzature = dati\_progetto.CostoAttrezzature + NEW.Costo;
                    \item IF OLD.CUP = NEW.CUP THEN
                    \begin{description}
                        \item dati\_progetto.CostoAttrezzature = dati\_progetto.CostoAttrezzature - OLD.Costo;
                    \end{description}
                    \item END IF;
                
                    \vspace{0.5cm}

                    \item half\_budget := (0.5 \* dati\_progetto.Budget)-0.005;
                
                    \vspace{0.5cm}

                    \item IF half\_budget >= dati\_progetto.CostoAttrezzature THEN
                    \begin{description}
                        \item UPDATE azienda.PROGETTO AS PR
                        \item SET costoAttrezzature = dati\_progetto.CostoAttrezzature
                        \item WHERE PR.CUP = NEW.CUP;

                        \vspace{0.5cm}

                        \item IF OLD.CUP <> NEW.CUP THEN
                        \begin{description}
                            \item UPDATE azienda.PROGETTO AS PR
                            \item SET costoAttrezzature = costoAttrezzature - OLD.Costo
                            \item WHERE PR.CUP = OLD.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item ELSE
                    \begin{description}
                        \item RAISE EXCEPTION 'Il costo totale delle attrezzature, ovvero €\%, sfora il 50\%\% del budget (€\%)! L''attrezzatura "\%" non è stata acquistata per il progetto \%', dati\_progetto.CostoAttrezzature, half\_budget, NEW.Descrizione, NEW.CUP;
                    \end{description}
                    \item END IF;
                
                    \item RETURN NEW;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_attrezzature\_e\_50\_U
                \item BEFORE UPDATE ON azienda.ATTREZZATURA
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_U();
            \end{description}
        \end{flushleft}
    \normalfont



    \subsubsection{incr\_costo\_attrezzature\_e\_50\_D (DELETE)}
    Il trigger "incr\_costo\_attrezzature\_e\_50\_D" gestisce la rimozione di attrezzature da un progetto. La funzione decrementa il costo dell'attrezzatura eliminata dal costo totale delle attrezzature del progetto.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_D()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoAttrezzature INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = OLD.CUP;
                
                    \vspace{0.5cm}

                    \item dati\_progetto.CostoAttrezzature = dati\_progetto.CostoAttrezzature - OLD.Costo;
                
                    \vspace{0.5cm}

                    \item UPDATE azienda.PROGETTO AS PR
                    \item SET costoAttrezzature = dati\_progetto.CostoAttrezzature
                    \item WHERE PR.CUP = OLD.CUP;
                
                    \item RETURN OLD;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_attrezzature\_e\_50\_D
                \item AFTER DELETE ON azienda.ATTREZZATURA
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_D();
            \end{description}
        \end{flushleft}
    \normalfont


\newpage

    \subsection{TRIGGERS PER azienda.DIP\_PROGETTO}

    \subsubsection{verifica\_dipProg}
    Il trigger "verifica\_dipProg" verificare se la data di scadenza di un dipendente a progetto è compresa tra le date di inizio e fine del progetto a cui è associato. Se la data di scadenza non rientra in questo intervallo, viene generata un'eccezione.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_verifica\_dipProg()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT dataInizio, dataFine INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = OLD.CUP;
                
                    \vspace{0.5cm}

                    \item IF NEW.Scadenza < dati\_progetto.dataInizio OR NEW.Scadenza > dati\_progetto.dataFine THEN
                    \begin{description}    
                        \item RAISE EXCEPTION 'La data di scadenza del dipendente a progetto \% non è compresa tra \%(inizio progetto) e \%(fine progetto)!', NEW.Matricola, dati\_progetto.dataInizio, dati\_progetto.dataFine;
                    \end{description}
                    \item END IF;
                    \item 
                    \item RETURN NEW; 

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_verifica\_dipProg
                \item BEFORE INSERT OR UPDATE OF Scadenza
                \item ON azienda.DIP\_PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_verifica\_dipProg();
            \end{description}
        \end{flushleft}
    \normalfont



    \subsubsection{incr\_costo\_dipProgetto\_e\_50\_I (INSERT)}
    Il trigger "incr\_costo\_dipProgetto\_e\_50\_I" controlla se il costo totale dei contratti di un progetto supera il 50\% del budget allocato per tale progetto. In caso contrario, viene aggiornato il costo dei contratti a progetto in "azienda.PROGETTO".
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_dipProgetto\_e\_50\_I()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                    \item half\_budget azienda.EURO := 0;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoContrattiProgetto INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = OLD.CUP;
                
                    \vspace{0.5cm}

                    \item dati\_progetto.costoContrattiProgetto = dati\_progetto.costoContrattiProgetto + NEW.Costo;

	                \item half\_budget := (0.5 * dati\_progetto.Budget)-0.005;
	                
                    \vspace{0.5cm}

                    \item IF half\_budget >= dati\_progetto.costoContrattiProgetto THEN
                    \begin{description}    
                        \item UPDATE azienda.PROGETTO AS PR
                        \item SET costoContrattiProgetto = dati\_progetto.costoContrattiProgetto
                        \item WHERE PR.CUP = NEW.CUP;
                    \end{description}
                    \item ELSE
                    \begin{description}
                        \item RAISE EXCEPTION 'Il costo totale dei contratti a progetto, ovvero €\%, sfora il 50\%\% del budget (€\%)! Il contratto \% è stato annullato per il progetto \%', dati\_progetto.costoContrattiProgetto, half\_budget, NEW.Matricola, NEW.CUP;
                    \end{description}
                    \item END IF;
                    \item RETURN NEW;
                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_dipProgetto\_e\_50\_I
                \item BEFORE INSERT ON azienda.DIP\_PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_dipProgetto\_e\_50\_I();
            \end{description}
        \end{flushleft}
    \normalfont


    \subsubsection{incr\_costo\_dipProgetto\_e\_50\_U (UPDATE)}
    Il trigger "incr\_costo\_dipProgetto\_e\_50\_U" verifica se la modifica di un contratto associato a un progetto di un'azienda causa il superamento del 50\% del budget del progetto stesso. In caso contrario, viene aggiornato il costo dei contratti a progetto in "azienda.PROGETTO".
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_dipProgetto\_e\_50\_U()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                    \item half\_budget azienda.EURO := 0;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoContrattiProgetto INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = NEW.CUP;
                    
                    \vspace{0.5cm}

                    \item dati\_progetto.costoContrattiProgetto = dati\_progetto.costoContrattiProgetto + NEW.Costo;
                    \item IF OLD.CUP = NEW.CUP THEN
                    \begin{description}
                        \item dati\_progetto.costoContrattiProgetto = dati\_progetto.costoContrattiProgetto - OLD.Costo;
                    \end{description}
                    \item END IF;
                
                    \vspace{0.5cm}

                    \item half\_budget := (0.5 \* dati\_progetto.Budget)-0.005;
                
                    \vspace{0.5cm}

                    \item IF half\_budget >= dati\_progetto.costoContrattiProgetto THEN
                    \begin{description}
                        \item UPDATE azienda.PROGETTO AS PR
                        \item SET costoContrattiProgetto = dati\_progetto.costoContrattiProgetto
                        \item WHERE PR.CUP = NEW.CUP;

                        \vspace{0.5cm}

                        \item IF OLD.CUP <> NEW.CUP THEN
                        \begin{description}
                            \item UPDATE azienda.PROGETTO AS PR
                            \item SET costoContrattiProgetto = costoContrattiProgetto - OLD.Costo
                            \item WHERE PR.CUP = OLD.CUP;
                        \end{description}
                        \item END IF;
                    \end{description}
                    \item ELSE
                    \begin{description}
                        \item RAISE EXCEPTION 'Il costo totale dei contratti a progetto, ovvero €\%, sfora il 50\%\% del budget (€\%)! Il contratto \% è stato annullato per il progetto \%', dati\_progetto.costoContrattiProgetto, half\_budget, NEW.Descrizione, NEW.CUP;
                    \end{description}
                    \item END IF;
                
                    \item RETURN NEW;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_dipProgetto\_e\_50\_U
                \item BEFORE UPDATE ON azienda.DIP\_PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_dipProgetto\_e\_50\_U();
            \end{description}
        \end{flushleft}
    \normalfont


    \subsubsection{incr\_incr\_costo\_dipProgetto\_e\_50\_D (DELETE)}
    Il trigger "incr\_costo\_dipProgetto\_e\_50\_D" gestisce l'eliminazione di record dalla tabella azienda.DIP\_PROGETTO. In particolare la funzione associata al trigger aggiorna il valore della colonna "costoContrattiProgetto" nella tabella azienda.PROGETTO, sottraendo il valore del costo dell'elemento eliminato.
    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE FUNCTION azienda.fn\_incr\_costo\_attrezzature\_e\_50\_D()  
                \item RETURNS trigger
                \item AS
                \item \$\$
                \item DECLARE
                \begin{description}
                    \item dati\_progetto record;
                \end{description}
                \item BEGIN 
                \begin{description}
                    \item SELECT Budget, costoContrattiProgetto INTO dati\_progetto
                    \item FROM azienda.PROGETTO
                    \item WHERE CUP = OLD.CUP;
                
                    \vspace{0.5cm}

                    \item dati\_progetto.costoContrattiProgetto = dati\_progetto.costoContrattiProgetto - OLD.Costo;
                
                    \vspace{0.5cm}

                    \item UPDATE azienda.PROGETTO AS PR
                    \item SET costoContrattiProgetto = dati\_progetto.costoContrattiProgetto
                    \item WHERE PR.CUP = OLD.CUP;
                
                    \item RETURN OLD;

                \end{description}

                \item END;
                \item \$\$
                \item LANGUAGE plpgsql;
            \end{description}
        \end{flushleft}
    \normalfont

    \ttfamily
        \begin{flushleft}
            \begin{description}
                \item CREATE OR REPLACE TRIGGER tr\_incr\_costo\_dipProgetto\_e\_50\_D
                \item AFTER DELETE ON azienda.DIP\_PROGETTO
                \item FOR EACH ROW
                \item EXECUTE FUNCTION azienda.fn\_incr\_costo\_dipProgetto\_e\_50\_D();
            \end{description}
        \end{flushleft}
    \normalfont